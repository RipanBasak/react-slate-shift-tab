{"version":3,"file":"slate-hyperscript.es.js","sources":["../src/index.js"],"sourcesContent":["import isEmpty from 'is-empty'\nimport isPlainObject from 'is-plain-object'\n\nimport {\n  Block,\n  Document,\n  Inline,\n  Mark,\n  Node,\n  Range,\n  Text,\n  Value,\n} from '@gitbook/slate'\n\n/**\n * Create selection point constants, for comparison by reference.\n *\n * @type {Object}\n */\n\nconst ANCHOR = {}\nconst CURSOR = {}\nconst FOCUS = {}\n\n/**\n *  wrappers for decorator points, for comparison by instanceof,\n *  and for composition into ranges (anchor.combine(focus), etc)\n */\n\nclass DecoratorPoint {\n  constructor({ key, data }, marks) {\n    this._key = key\n    this.marks = marks\n    this.attribs = data || {}\n    this.isAtomic = !!this.attribs.atomic\n    delete this.attribs.atomic\n    return this\n  }\n  withPosition = offset => {\n    this.offset = offset\n    return this\n  }\n  addOffset = offset => {\n    this.offset += offset\n    return this\n  }\n  withKey = key => {\n    this.key = key\n    return this\n  }\n  combine = focus => {\n    if (!(focus instanceof DecoratorPoint))\n      throw new Error('misaligned decorations')\n    return Range.create({\n      anchorKey: this.key,\n      focusKey: focus.key,\n      anchorOffset: this.offset,\n      focusOffset: focus.offset,\n      marks: this.marks,\n      isAtomic: this.isAtomic,\n      ...this.attribs,\n    })\n  }\n}\n\n/**\n * The default Slate hyperscript creator functions.\n *\n * @type {Object}\n */\n\nconst CREATORS = {\n  anchor(tagName, attributes, children) {\n    return ANCHOR\n  },\n\n  block(tagName, attributes, children) {\n    return Block.create({\n      ...attributes,\n      nodes: createChildren(children),\n    })\n  },\n\n  cursor(tagName, attributes, children) {\n    return CURSOR\n  },\n\n  document(tagName, attributes, children) {\n    return Document.create({\n      ...attributes,\n      nodes: createChildren(children),\n    })\n  },\n\n  focus(tagName, attributes, children) {\n    return FOCUS\n  },\n\n  inline(tagName, attributes, children) {\n    return Inline.create({\n      ...attributes,\n      nodes: createChildren(children),\n    })\n  },\n\n  mark(tagName, attributes, children) {\n    const marks = Mark.createSet([attributes])\n    const nodes = createChildren(children, { marks })\n    return nodes\n  },\n\n  decoration(tagName, attributes, children) {\n    if (attributes.key) {\n      return new DecoratorPoint(attributes, [{ type: tagName }])\n    }\n\n    const nodes = createChildren(children, { key: attributes.key })\n\n    nodes[0].__decorations = (nodes[0].__decorations || []).concat([\n      {\n        anchorOffset: 0,\n        focusOffset: nodes.reduce((len, n) => len + n.text.length, 0),\n        marks: [{ type: tagName }],\n        isAtomic: !!attributes.data.atomic,\n      },\n    ])\n    return nodes\n  },\n\n  selection(tagName, attributes, children) {\n    return Range.create(attributes)\n  },\n\n  value(tagName, attributes, children) {\n    const { data, normalize = true } = attributes\n    const document = children.find(Document.isDocument)\n    let selection = children.find(Range.isRange) || Range.create()\n    const props = {}\n    let decorations = []\n    const partialDecorations = {}\n\n    // Search the document's texts to see if any of them have the anchor or\n    // focus information saved, so we can set the selection.\n    if (document) {\n      document.getTexts().forEach(text => {\n        if (text.__anchor != null) {\n          props.anchorKey = text.key\n          props.anchorOffset = text.__anchor\n          props.isFocused = true\n        }\n\n        if (text.__focus != null) {\n          props.focusKey = text.key\n          props.focusOffset = text.__focus\n          props.isFocused = true\n        }\n      })\n\n      // now check for decorations and hoist them to the top\n      document.getTexts().forEach(text => {\n        if (text.__decorations != null) {\n          // add in all mark-like (keyless) decorations\n          decorations = decorations.concat(\n            text.__decorations.filter(d => d._key === undefined).map(d =>\n              Range.create({\n                ...d,\n                anchorKey: text.key,\n                focusKey: text.key,\n              })\n            )\n          )\n\n          // store or combine partial decorations (keyed with anchor / focus)\n          text.__decorations\n            .filter(d => d._key !== undefined)\n            .forEach(partial => {\n              if (partialDecorations[partial._key]) {\n                decorations.push(\n                  partialDecorations[partial._key].combine(\n                    partial.withKey(text.key)\n                  )\n                )\n\n                delete partialDecorations[partial._key]\n                return\n              }\n\n              partialDecorations[partial._key] = partial.withKey(text.key)\n            })\n        }\n      })\n    }\n\n    // should have no more parital decorations outstanding (all paired)\n    if (Object.keys(partialDecorations).length > 0) {\n      throw new Error(\n        `Slate hyperscript must have both an anchor and focus defined for each keyed decorator.`\n      )\n    }\n\n    if (props.anchorKey && !props.focusKey) {\n      throw new Error(\n        `Slate hyperscript must have both \\`<anchor/>\\` and \\`<focus/>\\` defined if one is defined, but you only defined \\`<anchor/>\\`. For collapsed selections, use \\`<cursor/>\\`.`\n      )\n    }\n\n    if (!props.anchorKey && props.focusKey) {\n      throw new Error(\n        `Slate hyperscript must have both \\`<anchor/>\\` and \\`<focus/>\\` defined if one is defined, but you only defined \\`<focus/>\\`. For collapsed selections, use \\`<cursor/>\\`.`\n      )\n    }\n\n    if (!isEmpty(props)) {\n      selection = selection.merge(props).normalize(document)\n    }\n\n    let value = Value.fromJS({ data, document, selection }, { normalize })\n\n    // apply any decorations built\n    if (decorations.length > 0) {\n      value = value\n        .change()\n        .setValue({ decorations: decorations.map(d => d.normalize(document)) })\n        .value\n    }\n\n    return value\n  },\n\n  text(tagName, attributes, children) {\n    const nodes = createChildren(children, { key: attributes.key })\n    return nodes\n  },\n}\n\n/**\n * Create a Slate hyperscript function with `options`.\n *\n * @param {Object} options\n * @return {Function}\n */\n\nfunction createHyperscript(options = {}) {\n  const creators = resolveCreators(options)\n\n  function create(tagName, attributes, ...children) {\n    const creator = creators[tagName]\n\n    if (!creator) {\n      throw new Error(`No hyperscript creator found for tag: \"${tagName}\"`)\n    }\n\n    if (attributes == null) {\n      attributes = {}\n    }\n\n    if (!isPlainObject(attributes)) {\n      children = [attributes].concat(children)\n      attributes = {}\n    }\n\n    children = children\n      .filter(child => Boolean(child))\n      .reduce((memo, child) => memo.concat(child), [])\n\n    const element = creator(tagName, attributes, children)\n    return element\n  }\n\n  return create\n}\n\n/**\n * Create an array of `children`, storing selection anchor and focus.\n *\n * @param {Array} children\n * @param {Object} options\n * @return {Array}\n */\n\nfunction createChildren(children, options = {}) {\n  const array = []\n  let length = 0\n\n  // When creating the new node, try to preserve a key if one exists.\n  const firstNodeOrText = children.find(c => typeof c !== 'string')\n  const firstText = Text.isText(firstNodeOrText) ? firstNodeOrText : null\n  const key = options.key ? options.key : firstText ? firstText.key : undefined\n  let node = Text.create({ key, leaves: [{ text: '', marks: options.marks }] })\n\n  // Create a helper to update the current node while preserving any stored\n  // anchor or focus information.\n  function setNode(next) {\n    const { __anchor, __focus, __decorations } = node\n    if (__anchor != null) next.__anchor = __anchor\n    if (__focus != null) next.__focus = __focus\n    if (__decorations != null) next.__decorations = __decorations\n    node = next\n  }\n\n  children.forEach((child, index) => {\n    const isLast = index === children.length - 1\n\n    // If the child is a non-text node, push the current node and the new child\n    // onto the array, then creating a new node for future selection tracking.\n    if (Node.isNode(child) && !Text.isText(child)) {\n      if (\n        node.text.length ||\n        node.__anchor != null ||\n        node.__focus != null ||\n        node.getMarksAtIndex(0).size\n      ) {\n        array.push(node)\n      }\n\n      array.push(child)\n\n      node = isLast\n        ? null\n        : Text.create({ leaves: [{ text: '', marks: options.marks }] })\n\n      length = 0\n    }\n\n    // If the child is a string insert it into the node.\n    if (typeof child == 'string') {\n      setNode(node.insertText(node.text.length, child, options.marks))\n      length += child.length\n    }\n\n    // If the node is a `Text` add its text and marks to the existing node. If\n    // the existing node is empty, and the `key` option wasn't set, preserve the\n    // child's key when updating the node.\n    if (Text.isText(child)) {\n      const { __anchor, __focus, __decorations } = child\n      let i = node.text.length\n\n      if (!options.key && node.text.length == 0) {\n        setNode(node.set('key', child.key))\n      }\n\n      child.getLeaves().forEach(leaf => {\n        let { marks } = leaf\n        if (options.marks) marks = marks.union(options.marks)\n        setNode(node.insertText(i, leaf.text, marks))\n        i += leaf.text.length\n      })\n\n      if (__anchor != null) node.__anchor = __anchor + length\n      if (__focus != null) node.__focus = __focus + length\n\n      if (__decorations != null) {\n        node.__decorations = (node.__decorations || []).concat(\n          __decorations.map(\n            d =>\n              d instanceof DecoratorPoint\n                ? d.addOffset(length)\n                : {\n                    ...d,\n                    anchorOffset: d.anchorOffset + length,\n                    focusOffset: d.focusOffset + length,\n                  }\n          )\n        )\n      }\n\n      length += child.text.length\n    }\n\n    // If the child is a selection object store the current position.\n    if (child == ANCHOR || child == CURSOR) node.__anchor = length\n    if (child == FOCUS || child == CURSOR) node.__focus = length\n\n    // if child is a decorator point, store it as partial decorator\n    if (child instanceof DecoratorPoint) {\n      node.__decorations = (node.__decorations || []).concat([\n        child.withPosition(length),\n      ])\n    }\n  })\n\n  // Make sure the most recent node is added.\n  if (node != null) {\n    array.push(node)\n  }\n\n  return array\n}\n\n/**\n * Resolve a set of hyperscript creators an `options` object.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction resolveCreators(options) {\n  const { blocks = {}, inlines = {}, marks = {}, decorators = {} } = options\n\n  const creators = {\n    ...CREATORS,\n    ...(options.creators || {}),\n  }\n\n  Object.keys(blocks).map(key => {\n    creators[key] = normalizeNode(key, blocks[key], 'block')\n  })\n\n  Object.keys(inlines).map(key => {\n    creators[key] = normalizeNode(key, inlines[key], 'inline')\n  })\n\n  Object.keys(marks).map(key => {\n    creators[key] = normalizeMark(key, marks[key])\n  })\n\n  Object.keys(decorators).map(key => {\n    creators[key] = normalizeNode(key, decorators[key], 'decoration')\n  })\n\n  return creators\n}\n\n/**\n * Normalize a node creator with `key` and `value`, of `object`.\n *\n * @param {String} key\n * @param {Function|Object|String} value\n * @param {String} object\n * @return {Function}\n */\n\nfunction normalizeNode(key, value, object) {\n  if (typeof value == 'function') {\n    return value\n  }\n\n  if (typeof value == 'string') {\n    value = { type: value }\n  }\n\n  if (isPlainObject(value)) {\n    return (tagName, attributes, children) => {\n      const { key: attrKey, ...rest } = attributes\n      const attrs = {\n        ...value,\n        object,\n        key: attrKey,\n        data: {\n          ...(value.data || {}),\n          ...rest,\n        },\n      }\n\n      return CREATORS[object](tagName, attrs, children)\n    }\n  }\n\n  throw new Error(\n    `Slate hyperscript ${object} creators can be either functions, objects or strings, but you passed: ${value}`\n  )\n}\n\n/**\n * Normalize a mark creator with `key` and `value`.\n *\n * @param {String} key\n * @param {Function|Object|String} value\n * @return {Function}\n */\n\nfunction normalizeMark(key, value) {\n  if (typeof value == 'function') {\n    return value\n  }\n\n  if (typeof value == 'string') {\n    value = { type: value }\n  }\n\n  if (isPlainObject(value)) {\n    return (tagName, attributes, children) => {\n      const attrs = {\n        ...value,\n        data: {\n          ...(value.data || {}),\n          ...attributes,\n        },\n      }\n\n      return CREATORS.mark(tagName, attrs, children)\n    }\n  }\n\n  throw new Error(\n    `Slate hyperscript mark creators can be either functions, objects or strings, but you passed: ${value}`\n  )\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default createHyperscript()\nexport { createHyperscript }\n"],"names":["ANCHOR","CURSOR","FOCUS","DecoratorPoint","marks","key","data","_key","attribs","isAtomic","atomic","withPosition","offset","addOffset","withKey","combine","focus","Error","Range","create","CREATORS","tagName","attributes","children","Block","createChildren","Document","Inline","Mark","createSet","nodes","type","__decorations","concat","reduce","len","n","text","length","normalize","document","find","isDocument","selection","isRange","props","decorations","partialDecorations","getTexts","forEach","__anchor","anchorKey","anchorOffset","isFocused","__focus","focusKey","focusOffset","filter","d","undefined","map","partial","push","Object","keys","isEmpty","merge","value","Value","fromJS","change","setValue","createHyperscript","options","creators","resolveCreators","creator","isPlainObject","Boolean","child","memo","element","array","firstNodeOrText","c","firstText","Text","isText","node","leaves","setNode","next","index","isLast","Node","isNode","getMarksAtIndex","size","insertText","i","set","getLeaves","leaf","union","blocks","inlines","decorators","normalizeNode","normalizeMark","object","attrKey","rest","attrs","mark"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;;;;;;AAMA,IAAMA,SAAS,EAAf;AACA,IAAMC,SAAS,EAAf;AACA,IAAMC,QAAQ,EAAd;;;;;;;IAOMC,iBACJ,8BAA2BC,KAA3B,EAAkC;MAApBC,GAAoB,QAApBA,GAAoB;MAAfC,IAAe,QAAfA,IAAe;;;;;OAC3BC,IAAL,GAAYF,GAAZ;OACKD,KAAL,GAAaA,KAAb;OACKI,OAAL,GAAeF,QAAQ,EAAvB;OACKG,QAAL,GAAgB,CAAC,CAAC,KAAKD,OAAL,CAAaE,MAA/B;SACO,KAAKF,OAAL,CAAaE,MAApB;SACO,IAAP;;;;;;;;;;;;OAEFC,eAAe,kBAAU;UAClBC,MAAL,GAAcA,MAAd;;;;OAGFC,YAAY,kBAAU;UACfD,MAAL,IAAeA,MAAf;;;;OAGFE,UAAU,eAAO;UACVT,GAAL,GAAWA,GAAX;;;;OAGFU,UAAU,iBAAS;QACb,EAAEC,iBAAiBb,cAAnB,CAAJ,EACE,MAAM,IAAIc,KAAJ,CAAU,wBAAV,CAAN;WACKC,MAAMC,MAAN;iBACM,MAAKd,GADX;gBAEKW,MAAMX,GAFX;oBAGS,MAAKO,MAHd;mBAIQI,MAAMJ,MAJd;aAKE,MAAKR,KALP;gBAMK,MAAKK;OACZ,MAAKD,OAPH,EAAP;;;;AAkBJ,IAAMY,WAAW;QAAA,kBACRC,OADQ,EACCC,UADD,EACaC,QADb,EACuB;WAC7BvB,MAAP;GAFa;OAAA,iBAKTqB,OALS,EAKAC,UALA,EAKYC,QALZ,EAKsB;WAC5BC,MAAML,MAAN,cACFG,UADE;aAEEG,eAAeF,QAAf;OAFT;GANa;QAAA,kBAYRF,OAZQ,EAYCC,UAZD,EAYaC,QAZb,EAYuB;WAC7BtB,MAAP;GAba;UAAA,oBAgBNoB,OAhBM,EAgBGC,UAhBH,EAgBeC,QAhBf,EAgByB;WAC/BG,SAASP,MAAT,cACFG,UADE;aAEEG,eAAeF,QAAf;OAFT;GAjBa;OAAA,iBAuBTF,OAvBS,EAuBAC,UAvBA,EAuBYC,QAvBZ,EAuBsB;WAC5BrB,KAAP;GAxBa;QAAA,kBA2BRmB,OA3BQ,EA2BCC,UA3BD,EA2BaC,QA3Bb,EA2BuB;WAC7BI,OAAOR,MAAP,cACFG,UADE;aAEEG,eAAeF,QAAf;OAFT;GA5Ba;MAAA,gBAkCVF,OAlCU,EAkCDC,UAlCC,EAkCWC,QAlCX,EAkCqB;QAC5BnB,QAAQwB,KAAKC,SAAL,CAAe,CAACP,UAAD,CAAf,CAAd;QACMQ,QAAQL,eAAeF,QAAf,EAAyB,EAAEnB,YAAF,EAAzB,CAAd;WACO0B,KAAP;GArCa;YAAA,sBAwCJT,OAxCI,EAwCKC,UAxCL,EAwCiBC,QAxCjB,EAwC2B;QACpCD,WAAWjB,GAAf,EAAoB;aACX,IAAIF,cAAJ,CAAmBmB,UAAnB,EAA+B,CAAC,EAAES,MAAMV,OAAR,EAAD,CAA/B,CAAP;;;QAGIS,QAAQL,eAAeF,QAAf,EAAyB,EAAElB,KAAKiB,WAAWjB,GAAlB,EAAzB,CAAd;;UAEM,CAAN,EAAS2B,aAAT,GAAyB,CAACF,MAAM,CAAN,EAASE,aAAT,IAA0B,EAA3B,EAA+BC,MAA/B,CAAsC,CAC7D;oBACgB,CADhB;mBAEeH,MAAMI,MAAN,CAAa,UAACC,GAAD,EAAMC,CAAN;eAAYD,MAAMC,EAAEC,IAAF,CAAOC,MAAzB;OAAb,EAA8C,CAA9C,CAFf;aAGS,CAAC,EAAEP,MAAMV,OAAR,EAAD,CAHT;gBAIY,CAAC,CAACC,WAAWhB,IAAX,CAAgBI;KAL+B,CAAtC,CAAzB;WAQOoB,KAAP;GAvDa;WAAA,qBA0DLT,OA1DK,EA0DIC,UA1DJ,EA0DgBC,QA1DhB,EA0D0B;WAChCL,MAAMC,MAAN,CAAaG,UAAb,CAAP;GA3Da;OAAA,iBA8DTD,OA9DS,EA8DAC,UA9DA,EA8DYC,QA9DZ,EA8DsB;QAC3BjB,IAD2B,GACAgB,UADA,CAC3BhB,IAD2B;gCACAgB,UADA,CACrBiB,SADqB;QACrBA,SADqB,yCACT,IADS;;QAE7BC,WAAWjB,SAASkB,IAAT,CAAcf,SAASgB,UAAvB,CAAjB;QACIC,YAAYpB,SAASkB,IAAT,CAAcvB,MAAM0B,OAApB,KAAgC1B,MAAMC,MAAN,EAAhD;QACM0B,QAAQ,EAAd;QACIC,cAAc,EAAlB;QACMC,qBAAqB,EAA3B;;;;QAIIP,QAAJ,EAAc;eACHQ,QAAT,GAAoBC,OAApB,CAA4B,gBAAQ;YAC9BZ,KAAKa,QAAL,IAAiB,IAArB,EAA2B;gBACnBC,SAAN,GAAkBd,KAAKhC,GAAvB;gBACM+C,YAAN,GAAqBf,KAAKa,QAA1B;gBACMG,SAAN,GAAkB,IAAlB;;;YAGEhB,KAAKiB,OAAL,IAAgB,IAApB,EAA0B;gBAClBC,QAAN,GAAiBlB,KAAKhC,GAAtB;gBACMmD,WAAN,GAAoBnB,KAAKiB,OAAzB;gBACMD,SAAN,GAAkB,IAAlB;;OAVJ;;;eAeSL,QAAT,GAAoBC,OAApB,CAA4B,gBAAQ;YAC9BZ,KAAKL,aAAL,IAAsB,IAA1B,EAAgC;;wBAEhBc,YAAYb,MAAZ,CACZI,KAAKL,aAAL,CAAmByB,MAAnB,CAA0B;mBAAKC,EAAEnD,IAAF,KAAWoD,SAAhB;WAA1B,EAAqDC,GAArD,CAAyD;mBACvD1C,MAAMC,MAAN,cACKuC,CADL;yBAEarB,KAAKhC,GAFlB;wBAGYgC,KAAKhC;eAJsC;WAAzD,CADY,CAAd;;;eAWK2B,aAAL,CACGyB,MADH,CACU;mBAAKC,EAAEnD,IAAF,KAAWoD,SAAhB;WADV,EAEGV,OAFH,CAEW,mBAAW;gBACdF,mBAAmBc,QAAQtD,IAA3B,CAAJ,EAAsC;0BACxBuD,IAAZ,CACEf,mBAAmBc,QAAQtD,IAA3B,EAAiCQ,OAAjC,CACE8C,QAAQ/C,OAAR,CAAgBuB,KAAKhC,GAArB,CADF,CADF;;qBAMO0C,mBAAmBc,QAAQtD,IAA3B,CAAP;;;;+BAIiBsD,QAAQtD,IAA3B,IAAmCsD,QAAQ/C,OAAR,CAAgBuB,KAAKhC,GAArB,CAAnC;WAdJ;;OAdJ;;;;QAmCE0D,OAAOC,IAAP,CAAYjB,kBAAZ,EAAgCT,MAAhC,GAAyC,CAA7C,EAAgD;YACxC,IAAIrB,KAAJ,0FAAN;;;QAKE4B,MAAMM,SAAN,IAAmB,CAACN,MAAMU,QAA9B,EAAwC;YAChC,IAAItC,KAAJ,uKAAN;;;QAKE,CAAC4B,MAAMM,SAAP,IAAoBN,MAAMU,QAA9B,EAAwC;YAChC,IAAItC,KAAJ,sKAAN;;;QAKE,CAACgD,QAAQpB,KAAR,CAAL,EAAqB;kBACPF,UAAUuB,KAAV,CAAgBrB,KAAhB,EAAuBN,SAAvB,CAAiCC,QAAjC,CAAZ;;;QAGE2B,QAAQC,MAAMC,MAAN,CAAa,EAAE/D,UAAF,EAAQkC,kBAAR,EAAkBG,oBAAlB,EAAb,EAA4C,EAAEJ,oBAAF,EAA5C,CAAZ;;;QAGIO,YAAYR,MAAZ,GAAqB,CAAzB,EAA4B;cAClB6B,MACLG,MADK,GAELC,QAFK,CAEI,EAAEzB,aAAaA,YAAYc,GAAZ,CAAgB;iBAAKF,EAAEnB,SAAF,CAAYC,QAAZ,CAAL;SAAhB,CAAf,EAFJ,EAGL2B,KAHH;;;WAMKA,KAAP;GA3Ja;MAAA,gBA8JV9C,OA9JU,EA8JDC,UA9JC,EA8JWC,QA9JX,EA8JqB;QAC5BO,QAAQL,eAAeF,QAAf,EAAyB,EAAElB,KAAKiB,WAAWjB,GAAlB,EAAzB,CAAd;WACOyB,KAAP;;CAhKJ;;;;;;;;;AA2KA,SAAS0C,iBAAT,GAAyC;MAAdC,OAAc,uEAAJ,EAAI;;MACjCC,WAAWC,gBAAgBF,OAAhB,CAAjB;;WAEStD,MAAT,CAAgBE,OAAhB,EAAyBC,UAAzB,EAAkD;sCAAVC,QAAU;cAAA;;;QAC1CqD,UAAUF,SAASrD,OAAT,CAAhB;;QAEI,CAACuD,OAAL,EAAc;YACN,IAAI3D,KAAJ,6CAAoDI,OAApD,OAAN;;;QAGEC,cAAc,IAAlB,EAAwB;mBACT,EAAb;;;QAGE,CAACuD,cAAcvD,UAAd,CAAL,EAAgC;iBACnB,CAACA,UAAD,EAAaW,MAAb,CAAoBV,QAApB,CAAX;mBACa,EAAb;;;eAGSA,SACRkC,MADQ,CACD;aAASqB,QAAQC,KAAR,CAAT;KADC,EAER7C,MAFQ,CAED,UAAC8C,IAAD,EAAOD,KAAP;aAAiBC,KAAK/C,MAAL,CAAY8C,KAAZ,CAAjB;KAFC,EAEoC,EAFpC,CAAX;;QAIME,UAAUL,QAAQvD,OAAR,EAAiBC,UAAjB,EAA6BC,QAA7B,CAAhB;WACO0D,OAAP;;;SAGK9D,MAAP;;;;;;;;;;;AAWF,SAASM,cAAT,CAAwBF,QAAxB,EAAgD;MAAdkD,OAAc,uEAAJ,EAAI;;MACxCS,QAAQ,EAAd;MACI5C,SAAS,CAAb;;;MAGM6C,kBAAkB5D,SAASkB,IAAT,CAAc;WAAK,OAAO2C,CAAP,KAAa,QAAlB;GAAd,CAAxB;MACMC,YAAYC,KAAKC,MAAL,CAAYJ,eAAZ,IAA+BA,eAA/B,GAAiD,IAAnE;MACM9E,MAAMoE,QAAQpE,GAAR,GAAcoE,QAAQpE,GAAtB,GAA4BgF,YAAYA,UAAUhF,GAAtB,GAA4BsD,SAApE;MACI6B,OAAOF,KAAKnE,MAAL,CAAY,EAAEd,QAAF,EAAOoF,QAAQ,CAAC,EAAEpD,MAAM,EAAR,EAAYjC,OAAOqE,QAAQrE,KAA3B,EAAD,CAAf,EAAZ,CAAX;;;;WAISsF,OAAT,CAAiBC,IAAjB,EAAuB;gBACwBH,IADxB;QACbtC,QADa,SACbA,QADa;QACHI,OADG,SACHA,OADG;QACMtB,aADN,SACMA,aADN;;QAEjBkB,YAAY,IAAhB,EAAsByC,KAAKzC,QAAL,GAAgBA,QAAhB;QAClBI,WAAW,IAAf,EAAqBqC,KAAKrC,OAAL,GAAeA,OAAf;QACjBtB,iBAAiB,IAArB,EAA2B2D,KAAK3D,aAAL,GAAqBA,aAArB;WACpB2D,IAAP;;;WAGO1C,OAAT,CAAiB,UAAC8B,KAAD,EAAQa,KAAR,EAAkB;QAC3BC,SAASD,UAAUrE,SAASe,MAAT,GAAkB,CAA3C;;;;QAIIwD,KAAKC,MAAL,CAAYhB,KAAZ,KAAsB,CAACO,KAAKC,MAAL,CAAYR,KAAZ,CAA3B,EAA+C;UAE3CS,KAAKnD,IAAL,CAAUC,MAAV,IACAkD,KAAKtC,QAAL,IAAiB,IADjB,IAEAsC,KAAKlC,OAAL,IAAgB,IAFhB,IAGAkC,KAAKQ,eAAL,CAAqB,CAArB,EAAwBC,IAJ1B,EAKE;cACMnC,IAAN,CAAW0B,IAAX;;;YAGI1B,IAAN,CAAWiB,KAAX;;aAEOc,SACH,IADG,GAEHP,KAAKnE,MAAL,CAAY,EAAEsE,QAAQ,CAAC,EAAEpD,MAAM,EAAR,EAAYjC,OAAOqE,QAAQrE,KAA3B,EAAD,CAAV,EAAZ,CAFJ;;eAIS,CAAT;;;;QAIE,OAAO2E,KAAP,IAAgB,QAApB,EAA8B;cACpBS,KAAKU,UAAL,CAAgBV,KAAKnD,IAAL,CAAUC,MAA1B,EAAkCyC,KAAlC,EAAyCN,QAAQrE,KAAjD,CAAR;gBACU2E,MAAMzC,MAAhB;;;;;;QAMEgD,KAAKC,MAAL,CAAYR,KAAZ,CAAJ,EAAwB;UACd7B,QADc,GACuB6B,KADvB,CACd7B,QADc;UACJI,OADI,GACuByB,KADvB,CACJzB,OADI;UACKtB,aADL,GACuB+C,KADvB,CACK/C,aADL;;UAElBmE,IAAIX,KAAKnD,IAAL,CAAUC,MAAlB;;UAEI,CAACmC,QAAQpE,GAAT,IAAgBmF,KAAKnD,IAAL,CAAUC,MAAV,IAAoB,CAAxC,EAA2C;gBACjCkD,KAAKY,GAAL,CAAS,KAAT,EAAgBrB,MAAM1E,GAAtB,CAAR;;;YAGIgG,SAAN,GAAkBpD,OAAlB,CAA0B,gBAAQ;YAC1B7C,KAD0B,GAChBkG,IADgB,CAC1BlG,KAD0B;;YAE5BqE,QAAQrE,KAAZ,EAAmBA,QAAQA,MAAMmG,KAAN,CAAY9B,QAAQrE,KAApB,CAAR;gBACXoF,KAAKU,UAAL,CAAgBC,CAAhB,EAAmBG,KAAKjE,IAAxB,EAA8BjC,KAA9B,CAAR;aACKkG,KAAKjE,IAAL,CAAUC,MAAf;OAJF;;UAOIY,YAAY,IAAhB,EAAsBsC,KAAKtC,QAAL,GAAgBA,WAAWZ,MAA3B;UAClBgB,WAAW,IAAf,EAAqBkC,KAAKlC,OAAL,GAAeA,UAAUhB,MAAzB;;UAEjBN,iBAAiB,IAArB,EAA2B;aACpBA,aAAL,GAAqB,CAACwD,KAAKxD,aAAL,IAAsB,EAAvB,EAA2BC,MAA3B,CACnBD,cAAc4B,GAAd,CACE;iBACEF,aAAavD,cAAb,GACIuD,EAAE7C,SAAF,CAAYyB,MAAZ,CADJ,gBAGSoB,CAHT;0BAIoBA,EAAEN,YAAF,GAAiBd,MAJrC;yBAKmBoB,EAAEF,WAAF,GAAgBlB;YANrC;SADF,CADmB,CAArB;;;gBAcQyC,MAAM1C,IAAN,CAAWC,MAArB;;;;QAIEyC,SAAS/E,MAAT,IAAmB+E,SAAS9E,MAAhC,EAAwCuF,KAAKtC,QAAL,GAAgBZ,MAAhB;QACpCyC,SAAS7E,KAAT,IAAkB6E,SAAS9E,MAA/B,EAAuCuF,KAAKlC,OAAL,GAAehB,MAAf;;;QAGnCyC,iBAAiB5E,cAArB,EAAqC;WAC9B6B,aAAL,GAAqB,CAACwD,KAAKxD,aAAL,IAAsB,EAAvB,EAA2BC,MAA3B,CAAkC,CACrD8C,MAAMpE,YAAN,CAAmB2B,MAAnB,CADqD,CAAlC,CAArB;;GA3EJ;;;MAkFIkD,QAAQ,IAAZ,EAAkB;UACV1B,IAAN,CAAW0B,IAAX;;;SAGKN,KAAP;;;;;;;;;;AAUF,SAASP,eAAT,CAAyBF,OAAzB,EAAkC;wBACmCA,OADnC,CACxB+B,MADwB;MACxBA,MADwB,mCACf,EADe;yBACmC/B,OADnC,CACXgC,OADW;MACXA,OADW,oCACD,EADC;uBACmChC,OADnC,CACGrE,KADH;MACGA,KADH,kCACW,EADX;4BACmCqE,OADnC,CACeiC,UADf;MACeA,UADf,uCAC4B,EAD5B;;;MAG1BhC,wBACDtD,QADC,EAEAqD,QAAQC,QAAR,IAAoB,EAFpB,CAAN;;SAKOV,IAAP,CAAYwC,MAAZ,EAAoB5C,GAApB,CAAwB,eAAO;aACpBvD,GAAT,IAAgBsG,cAActG,GAAd,EAAmBmG,OAAOnG,GAAP,CAAnB,EAAgC,OAAhC,CAAhB;GADF;;SAIO2D,IAAP,CAAYyC,OAAZ,EAAqB7C,GAArB,CAAyB,eAAO;aACrBvD,GAAT,IAAgBsG,cAActG,GAAd,EAAmBoG,QAAQpG,GAAR,CAAnB,EAAiC,QAAjC,CAAhB;GADF;;SAIO2D,IAAP,CAAY5D,KAAZ,EAAmBwD,GAAnB,CAAuB,eAAO;aACnBvD,GAAT,IAAgBuG,cAAcvG,GAAd,EAAmBD,MAAMC,GAAN,CAAnB,CAAhB;GADF;;SAIO2D,IAAP,CAAY0C,UAAZ,EAAwB9C,GAAxB,CAA4B,eAAO;aACxBvD,GAAT,IAAgBsG,cAActG,GAAd,EAAmBqG,WAAWrG,GAAX,CAAnB,EAAoC,YAApC,CAAhB;GADF;;SAIOqE,QAAP;;;;;;;;;;;;AAYF,SAASiC,aAAT,CAAuBtG,GAAvB,EAA4B8D,KAA5B,EAAmC0C,MAAnC,EAA2C;MACrC,OAAO1C,KAAP,IAAgB,UAApB,EAAgC;WACvBA,KAAP;;;MAGE,OAAOA,KAAP,IAAgB,QAApB,EAA8B;YACpB,EAAEpC,MAAMoC,KAAR,EAAR;;;MAGEU,cAAcV,KAAd,CAAJ,EAA0B;WACjB,UAAC9C,OAAD,EAAUC,UAAV,EAAsBC,QAAtB,EAAmC;UAC3BuF,OAD2B,GACNxF,UADM,CAChCjB,GADgC;UACf0G,IADe,2BACNzF,UADM;;UAElC0F,qBACD7C,KADC;sBAAA;aAGC2C,OAHD;2BAKE3C,MAAM7D,IAAN,IAAc,EADpB,EAEKyG,IAFL;QAJF;;aAUO3F,SAASyF,MAAT,EAAiBxF,OAAjB,EAA0B2F,KAA1B,EAAiCzF,QAAjC,CAAP;KAZF;;;QAgBI,IAAIN,KAAJ,wBACiB4F,MADjB,+EACiG1C,KADjG,CAAN;;;;;;;;;;;AAaF,SAASyC,aAAT,CAAuBvG,GAAvB,EAA4B8D,KAA5B,EAAmC;MAC7B,OAAOA,KAAP,IAAgB,UAApB,EAAgC;WACvBA,KAAP;;;MAGE,OAAOA,KAAP,IAAgB,QAApB,EAA8B;YACpB,EAAEpC,MAAMoC,KAAR,EAAR;;;MAGEU,cAAcV,KAAd,CAAJ,EAA0B;WACjB,UAAC9C,OAAD,EAAUC,UAAV,EAAsBC,QAAtB,EAAmC;UAClCyF,qBACD7C,KADC;2BAGEA,MAAM7D,IAAN,IAAc,EADpB,EAEKgB,UAFL;QAFF;;aAQOF,SAAS6F,IAAT,CAAc5F,OAAd,EAAuB2F,KAAvB,EAA8BzF,QAA9B,CAAP;KATF;;;QAaI,IAAIN,KAAJ,mGAC4FkD,KAD5F,CAAN;;;;;;;;;AAWF,YAAeK,mBAAf;;;;;"}