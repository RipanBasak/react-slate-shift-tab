{"version":3,"file":"slate.js","sources":["../src/constants/model-types.js","../src/utils/generate-key.js","../src/models/block.js","../src/models/inline.js","../src/models/data.js","../src/models/mark.js","../src/changes/at-current-range.js","../src/models/document.js","../src/models/range.js","../src/models/character.js","../src/models/leaf.js","../src/models/text.js","../src/models/node.js","../src/utils/string.js","../src/changes/at-range.js","../src/changes/by-key.js","../src/constants/operation-attributes.js","../src/models/history.js","../src/constants/core-schema-rules.js","../src/models/stack.js","../src/models/schema.js","../src/models/value.js","../src/models/operation.js","../src/operations/invert.js","../src/changes/on-history.js","../src/changes/on-selection.js","../src/changes/on-value.js","../src/changes/with-schema.js","../src/changes/index.js","../src/operations/apply.js","../src/models/change.js","../src/operations/index.js","../src/index.js"],"sourcesContent":["/**\n * Slate-specific model types.\n *\n * @type {Object}\n */\n\nconst MODEL_TYPES = {\n  BLOCK: '@@__SLATE_BLOCK__@@',\n  CHANGE: '@@__SLATE_CHANGE__@@',\n  CHARACTER: '@@__SLATE_CHARACTER__@@',\n  DOCUMENT: '@@__SLATE_DOCUMENT__@@',\n  HISTORY: '@@__SLATE_HISTORY__@@',\n  INLINE: '@@__SLATE_INLINE__@@',\n  LEAF: '@@__SLATE_LEAF__@@',\n  MARK: '@@__SLATE_MARK__@@',\n  OPERATION: '@@__SLATE_OPERATION__@@',\n  RANGE: '@@__SLATE_RANGE__@@',\n  SCHEMA: '@@__SLATE_SCHEMA__@@',\n  STACK: '@@__SLATE_STACK__@@',\n  TEXT: '@@__SLATE_TEXT__@@',\n  VALUE: '@@__SLATE_VALUE__@@',\n}\n\n/**\n * Export type identification function\n *\n * @param {string} type\n * @param {any} any\n * @return {boolean}\n */\n\nexport function isType(type, any) {\n  return !!(any && any[MODEL_TYPES[type]])\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default MODEL_TYPES\n","/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nlet n\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nlet generate\n\n/**\n * Generate a key.\n *\n * @return {String}\n */\n\nfunction generateKey() {\n  return generate()\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setKeyGenerator(func) {\n  generate = func\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetKeyGenerator() {\n  n = 0\n  generate = () => `${n++}`\n}\n\n/**\n * Set the initial state.\n */\n\nresetKeyGenerator()\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default generateKey\nexport { setKeyGenerator, resetKeyGenerator }\n","/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport generateKey from '../utils/generate-key'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new List(),\n  type: undefined,\n}\n\n/**\n * Block.\n *\n * @type {Block}\n */\n\nclass Block extends Record(DEFAULTS) {\n  /**\n   * Create a new `Block` from `attrs`.\n   *\n   * @param {Object|String|Block} attrs\n   * @return {Block}\n   */\n\n  static create(attrs = {}) {\n    if (Block.isBlock(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Block.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`Block.create\\` only accepts objects, strings or blocks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Blocks` from `attrs`.\n   *\n   * @param {Array<Block|Object>|List<Block|Object>} attrs\n   * @return {List<Block>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Block.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Block` from a JSON `object`.\n   *\n   * @param {Object|Block} object\n   * @return {Block}\n   */\n\n  static fromJS(object) {\n    if (Block.isBlock(object)) {\n      return object\n    }\n\n    const {\n      data = {},\n      isVoid = false,\n      key = generateKey(),\n      nodes = [],\n      type,\n    } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Block.fromJS` requires a `type` string.')\n    }\n\n    const block = new Block({\n      key,\n      type,\n      isVoid: !!isVoid,\n      data: Map(data),\n      nodes: Block.createChildren(nodes),\n    })\n\n    return block\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Block.fromJS(object)\n  }\n\n  /**\n   * Check if `any` is a `Block`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlock = isType.bind(null, 'BLOCK')\n\n  /**\n   * Check if `any` is a block list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlockList(any) {\n    return List.isList(any) && any.every(item => Block.isBlock(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'block'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the block is empty.\n   * Returns true if block is not void and all it's children nodes are empty.\n   * Void node is never empty, regardless of it's content.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return !this.isVoid && !this.nodes.some(child => !child.isEmpty)\n  }\n\n  /**\n   * Get the concatenated text of all the block's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the block.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJS(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      isVoid: this.isVoid,\n      data: this.data.toJS(),\n      nodes: this.nodes.toArray().map(n => n.toJS(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJSON`.\n   */\n\n  toJSON(options) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nBlock.prototype[MODEL_TYPES.BLOCK] = true\n\n/**\n * Export.\n *\n * @type {Block}\n */\n\nexport default Block\n","/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport generateKey from '../utils/generate-key'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  isVoid: false,\n  key: undefined,\n  nodes: new List(),\n  type: undefined,\n}\n\n/**\n * Inline.\n *\n * @type {Inline}\n */\n\nclass Inline extends Record(DEFAULTS) {\n  /**\n   * Create a new `Inline` with `attrs`.\n   *\n   * @param {Object|String|Inline} attrs\n   * @return {Inline}\n   */\n\n  static create(attrs = {}) {\n    if (Inline.isInline(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Inline.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`Inline.create\\` only accepts objects, strings or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Inlines` from an array.\n   *\n   * @param {Array<Inline|Object>|List<Inline|Object>} elements\n   * @return {List<Inline>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Inline.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Inline.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Inline` from a JSON `object`.\n   *\n   * @param {Object|Inline} object\n   * @return {Inline}\n   */\n\n  static fromJS(object) {\n    if (Inline.isInline(object)) {\n      return object\n    }\n\n    const {\n      data = {},\n      isVoid = false,\n      key = generateKey(),\n      nodes = [],\n      type,\n    } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Inline.fromJS` requires a `type` string.')\n    }\n\n    const inline = new Inline({\n      key,\n      type,\n      isVoid: !!isVoid,\n      data: new Map(data),\n      nodes: Inline.createChildren(nodes),\n    })\n\n    return inline\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Inline.fromJS(object)\n  }\n\n  /**\n   * Check if `any` is a `Inline`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInline = isType.bind(null, 'INLINE')\n\n  /**\n   * Check if `any` is a list of inlines.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInlineList(any) {\n    return List.isList(any) && any.every(item => Inline.isInline(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'inline'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the inline is empty.\n   * Returns true if inline is not void and all it's children nodes are empty.\n   * Void node is never empty, regardless of it's content.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return !this.isVoid && !this.nodes.some(child => !child.isEmpty)\n  }\n\n  /**\n   * Get the concatenated text of all the inline's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the inline.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJS(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      isVoid: this.isVoid,\n      data: this.data.toJS(),\n      nodes: this.nodes.toArray().map(n => n.toJS(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJSON(options) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nInline.prototype[MODEL_TYPES.INLINE] = true\n\n/**\n * Export.\n *\n * @type {Inline}\n */\n\nexport default Inline\n","import isPlainObject from 'is-plain-object'\nimport { Map } from 'immutable'\nimport logger from '@gitbook/slate-dev-logger'\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nclass Data {\n  /**\n   * Create a new `Data` with `attrs`.\n   *\n   * @param {Object|Data|Map} attrs\n   * @return {Data} data\n   */\n\n  static create(attrs = {}) {\n    if (Map.isMap(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Data.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`Data.create\\` only accepts objects or maps, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Data` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Data}\n   */\n\n  static fromJS(object) {\n    return new Map(object)\n  }\n\n  /**\n   * Alias `fromJSON`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Data.fromJS(object)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Data\n","import isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { Map, Record, Set } from 'immutable'\nimport memoize from 'immutablejs-record-memoize'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Data from './data'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  type: undefined,\n}\n\n/**\n * Mark.\n *\n * @type {Mark}\n */\n\nclass Mark extends Record(DEFAULTS) {\n  /**\n   * Create a new `Mark` with `attrs`.\n   *\n   * @param {Object|Mark} attrs\n   * @return {Mark}\n   */\n\n  static create(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Mark.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`Mark.create\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a set of marks.\n   *\n   * @param {Array<Object|Mark>} elements\n   * @return {Set<Mark>}\n   */\n\n  static createSet(elements) {\n    if (Set.isSet(elements) || Array.isArray(elements)) {\n      const marks = new Set(elements.map(Mark.create))\n      return marks\n    }\n\n    if (elements == null) {\n      return Set()\n    }\n\n    throw new Error(\n      `\\`Mark.createSet\\` only accepts sets, arrays or null, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable mark properties from `attrs`.\n   *\n   * @param {Object|String|Mark} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Mark.createProperties\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Mark` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Mark}\n   */\n\n  static fromJS(object) {\n    const { data = {}, type } = object\n\n    if (typeof type != 'string') {\n      throw new Error('`Mark.fromJS` requires a `type` string.')\n    }\n\n    const mark = new Mark({\n      type,\n      data: Data.fromJS(data),\n    })\n\n    return mark\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Mark.fromJS(object)\n  }\n\n  /**\n   * Check if `any` is a `Mark`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMark = isType.bind(null, 'MARK')\n\n  /**\n   * Check if `any` is a set of marks.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMarkSet(any) {\n    return Set.isSet(any) && any.every(item => Mark.isMark(item))\n  }\n\n  /**\n   * Object.\n   */\n\n  get object() {\n    return 'mark'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Get the component for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Component|Void}\n   */\n\n  getComponent(schema) {\n    return schema.__getComponent(this)\n  }\n\n  /**\n   * Return a JSON representation of the mark.\n   *\n   * @return {Object}\n   */\n\n  toJS() {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJS(),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJSON`.\n   */\n\n  toJSON() {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nMark.prototype[MODEL_TYPES.MARK] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Mark.prototype, ['getComponent'])\n\n/**\n * Export.\n *\n * @type {Mark}\n */\n\nexport default Mark\n","import logger from '@gitbook/slate-dev-logger'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Mix in the changes that pass through to their at-range equivalents because\n * they don't have any effect on the selection.\n */\n\nconst PROXY_TRANSFORMS = [\n  'deleteBackward',\n  'deleteCharBackward',\n  'deleteLineBackward',\n  'deleteWordBackward',\n  'deleteForward',\n  'deleteCharForward',\n  'deleteWordForward',\n  'deleteLineForward',\n  'setBlocks',\n  'setInlines',\n  'splitInline',\n  'unwrapBlock',\n  'unwrapInline',\n  'wrapBlock',\n  'wrapInline',\n]\n\nPROXY_TRANSFORMS.forEach(method => {\n  Changes[method] = (change, ...args) => {\n    const { value } = change\n    const { selection } = value\n    const methodAtRange = `${method}AtRange`\n    change[methodAtRange](selection, ...args)\n\n    if (method.match(/Backward$/)) {\n      change.collapseToStart()\n    } else if (method.match(/Forward$/)) {\n      change.collapseToEnd()\n    }\n  }\n})\n\nChanges.setBlock = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setBlock` method of Slate changes has been renamed to `setBlocks`.'\n  )\n\n  Changes.setBlocks(...args)\n}\n\nChanges.setInline = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setInline` method of Slate changes has been renamed to `setInlines`.'\n  )\n\n  Changes.setInlines(...args)\n}\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.addMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).add(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.addMarks = (change, marks) => {\n  marks.forEach(mark => change.addMark(mark))\n}\n\n/**\n * Delete at the current selection.\n *\n * @param {Change} change\n */\n\nChanges.delete = change => {\n  const { value } = change\n  const { selection } = value\n  change.deleteAtRange(selection)\n\n  // Ensure that the selection is collapsed to the start, because in certain\n  // cases when deleting across inline nodes, when splitting the inline node the\n  // end point of the selection will end up after the split point.\n  change.collapseToStart()\n}\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Block} block\n */\n\nChanges.insertBlock = (change, block) => {\n  block = Block.create(block)\n  const { value } = change\n  const { selection } = value\n  change.insertBlockAtRange(selection, block)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(block.key)\n  if (node) change.collapseToEndOf(node)\n}\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Change} change\n * @param {Document} fragment\n */\n\nChanges.insertFragment = (change, fragment) => {\n  if (!fragment.nodes.size) return\n\n  let { value } = change\n  let { document, selection } = value\n  const { startText, endText, startInline } = value\n  const lastText = fragment.getLastText()\n  const lastInline = fragment.getClosestInline(lastText.key)\n  const firstChild = fragment.nodes.first()\n  const lastChild = fragment.nodes.last()\n  const keys = document.getTexts().map(text => text.key)\n  const isAppending =\n    !startInline ||\n    selection.hasEdgeAtStartOf(startText) ||\n    selection.hasEdgeAtEndOf(endText)\n\n  const isInserting =\n    fragment.hasBlocks(firstChild.key) || fragment.hasBlocks(lastChild.key)\n\n  change.insertFragmentAtRange(selection, fragment)\n  value = change.value\n  document = value.document\n\n  const newTexts = document.getTexts().filter(n => !keys.includes(n.key))\n  const newText = isAppending ? newTexts.last() : newTexts.takeLast(2).first()\n\n  if (newText && (lastInline || isInserting)) {\n    change.select(selection.collapseToEndOf(newText))\n  } else if (newText) {\n    change.select(\n      selection.collapseToStartOf(newText).move(lastText.text.length)\n    )\n  } else {\n    change.select(selection.collapseToStart().move(lastText.text.length))\n  }\n}\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Change} change\n * @param {String|Object|Inline} inline\n */\n\nChanges.insertInline = (change, inline) => {\n  inline = Inline.create(inline)\n  const { value } = change\n  const { selection } = value\n  change.insertInlineAtRange(selection, inline)\n\n  // If the node was successfully inserted, update the selection.\n  const node = change.value.document.getNode(inline.key)\n  if (node) change.collapseToEndOf(node)\n}\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Change} change\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nChanges.insertText = (change, text, marks) => {\n  const { value } = change\n  const { document, selection } = value\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection)\n  change.insertTextAtRange(selection, text, marks)\n\n  // If the text was successfully inserted, and the selection had marks on it,\n  // unset the selection's marks.\n  if (selection.marks && document != change.value.document) {\n    change.select({ marks: null })\n  }\n}\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Change} change\n * @param {Number} depth (optional)\n */\n\nChanges.splitBlock = (change, depth = 1) => {\n  const { value } = change\n  const { selection, document } = value\n  const marks = selection.marks || document.getInsertMarksAtRange(selection)\n  change.splitBlockAtRange(selection, depth).collapseToEnd()\n\n  if (marks && marks.size !== 0) {\n    change.select({ marks })\n  }\n}\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.removeMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    change.removeMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).remove(mark)\n    const sel = selection.set('marks', marks)\n    change.select(sel)\n  }\n}\n\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Change} change\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\nChanges.replaceMark = (change, oldMark, newMark) => {\n  change.removeMark(oldMark)\n  change.addMark(newMark)\n}\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Change} change\n * @param {Mark} mark\n */\n\nChanges.toggleMark = (change, mark) => {\n  mark = Mark.create(mark)\n  const { value } = change\n  const exists = value.activeMarks.has(mark)\n\n  if (exists) {\n    change.removeMark(mark)\n  } else {\n    change.addMark(mark)\n  }\n}\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Change} change\n * @param {String} prefix\n * @param {String} suffix\n */\n\nChanges.wrapText = (change, prefix, suffix = prefix) => {\n  const { value } = change\n  const { selection } = value\n  change.wrapTextAtRange(selection, prefix, suffix)\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    change.moveStart(0 - prefix.length)\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  change.moveEnd(0 - suffix.length)\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward != change.value.selection.isForward) {\n    change.flip()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","/**\n * Dependencies.\n */\n\nimport isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { List, Map, Record } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport generateKey from '../utils/generate-key'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  key: undefined,\n  nodes: new List(),\n}\n\n/**\n * Document.\n *\n * @type {Document}\n */\n\nclass Document extends Record(DEFAULTS) {\n  /**\n   * Create a new `Document` with `attrs`.\n   *\n   * @param {Object|Array|List|Text} attrs\n   * @return {Document}\n   */\n\n  static create(attrs = {}) {\n    if (Document.isDocument(attrs)) {\n      return attrs\n    }\n\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      attrs = { nodes: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Document.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`Document.create\\` only accepts objects, arrays, lists or documents, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Document` from a JSON `object`.\n   *\n   * @param {Object|Document} object\n   * @return {Document}\n   */\n\n  static fromJS(object) {\n    if (Document.isDocument(object)) {\n      return object\n    }\n\n    const { data = {}, key = generateKey(), nodes = [] } = object\n\n    const document = new Document({\n      key,\n      data: new Map(data),\n      nodes: Document.createChildren(nodes),\n    })\n\n    return document\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Document.fromJS(object)\n  }\n\n  /**\n   * Check if `any` is a `Document`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isDocument = isType.bind(null, 'DOCUMENT')\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'document'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check if the document is empty.\n   * Returns true if all it's children nodes are empty.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return !this.nodes.some(child => !child.isEmpty)\n  }\n\n  /**\n   * Get the concatenated text of all the document's children.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Return a JSON representation of the document.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJS(options = {}) {\n    const object = {\n      object: this.object,\n      data: this.data.toJS(),\n      nodes: this.nodes.toArray().map(n => n.toJS(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJSON(options) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nDocument.prototype[MODEL_TYPES.DOCUMENT] = true\n\n/**\n * Export.\n *\n * @type {Document}\n */\n\nexport default Document\n","import isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { List, Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchorKey: null,\n  anchorOffset: 0,\n  focusKey: null,\n  focusOffset: 0,\n  isBackward: null,\n  isFocused: false,\n  marks: null,\n  isAtomic: false,\n}\n\n/**\n * Range.\n *\n * @type {Range}\n */\n\nclass Range extends Record(DEFAULTS) {\n  /**\n   * Create a new `Range` with `attrs`.\n   *\n   * @param {Object|Range} attrs\n   * @return {Range}\n   */\n\n  static create(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Range.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`Range.create\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Range|Object>|List<Range|Object>} elements\n   * @return {List<Range>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Range.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Range.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable range properties from `attrs`.\n   *\n   * @param {Object|String|Range} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      return {\n        anchorKey: attrs.anchorKey,\n        anchorOffset: attrs.anchorOffset,\n        focusKey: attrs.focusKey,\n        focusOffset: attrs.focusOffset,\n        isBackward: attrs.isBackward,\n        isFocused: attrs.isFocused,\n        marks: attrs.marks,\n        isAtomic: attrs.isAtomic,\n      }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('anchorKey' in attrs) props.anchorKey = attrs.anchorKey\n      if ('anchorOffset' in attrs) props.anchorOffset = attrs.anchorOffset\n      if ('anchorPath' in attrs) props.anchorPath = attrs.anchorPath\n      if ('focusKey' in attrs) props.focusKey = attrs.focusKey\n      if ('focusOffset' in attrs) props.focusOffset = attrs.focusOffset\n      if ('focusPath' in attrs) props.focusPath = attrs.focusPath\n      if ('isBackward' in attrs) props.isBackward = attrs.isBackward\n      if ('isFocused' in attrs) props.isFocused = attrs.isFocused\n      if ('marks' in attrs)\n        props.marks = attrs.marks == null ? null : Mark.createSet(attrs.marks)\n      if ('isAtomic' in attrs) props.isAtomic = attrs.isAtomic\n      return props\n    }\n\n    throw new Error(\n      `\\`Range.createProperties\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Range` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Range}\n   */\n\n  static fromJS(object) {\n    const {\n      anchorKey = null,\n      anchorOffset = 0,\n      focusKey = null,\n      focusOffset = 0,\n      isBackward = null,\n      isFocused = false,\n      marks = null,\n      isAtomic = false,\n    } = object\n\n    const range = new Range({\n      anchorKey,\n      anchorOffset,\n      focusKey,\n      focusOffset,\n      isBackward,\n      isFocused,\n      marks: marks == null ? null : Mark.createSet(marks),\n      isAtomic,\n    })\n\n    return range\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Range.fromJS(object)\n  }\n\n  /**\n   * Check if an `obj` is a `Range`.\n   *\n   * @param {Any} obj\n   * @return {Boolean}\n   */\n\n  static isRange(obj) {\n    return !!(obj && obj[MODEL_TYPES.RANGE])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'range'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Check whether the range is blurred.\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return !this.isFocused\n  }\n\n  /**\n   * Check whether the range is collapsed.\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return (\n      this.anchorKey == this.focusKey && this.anchorOffset == this.focusOffset\n    )\n  }\n\n  /**\n   * Check whether the range is expanded.\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return !this.isCollapsed\n  }\n\n  /**\n   * Check whether the range is forward.\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    return this.isBackward == null ? null : !this.isBackward\n  }\n\n  /**\n   * Check whether the range's keys are set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return this.anchorKey != null && this.focusKey != null\n  }\n\n  /**\n   * Check whether the range's keys are not set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    return !this.isSet\n  }\n\n  /**\n   * Get the start key.\n   *\n   * @return {String}\n   */\n\n  get startKey() {\n    return this.isBackward ? this.focusKey : this.anchorKey\n  }\n\n  /**\n   * Get the start offset.\n   *\n   * @return {String}\n   */\n\n  get startOffset() {\n    return this.isBackward ? this.focusOffset : this.anchorOffset\n  }\n\n  /**\n   * Get the end key.\n   *\n   * @return {String}\n   */\n\n  get endKey() {\n    return this.isBackward ? this.anchorKey : this.focusKey\n  }\n\n  /**\n   * Get the end offset.\n   *\n   * @return {String}\n   */\n\n  get endOffset() {\n    return this.isBackward ? this.anchorOffset : this.focusOffset\n  }\n\n  /**\n   * Check whether anchor point of the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorAtStartOf(node) {\n    // PERF: Do a check for a `0` offset first since it's quickest.\n    if (this.anchorOffset != 0) return false\n    const first = getFirst(node)\n    return this.anchorKey == first.key\n  }\n\n  /**\n   * Check whether anchor point of the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorAtEndOf(node) {\n    const last = getLast(node)\n    return this.anchorKey == last.key && this.anchorOffset == last.text.length\n  }\n\n  /**\n   * Check whether the anchor edge of a range is in a `node` and at an\n   * offset between `start` and `end`.\n   *\n   * @param {Node} node\n   * @param {Number} start\n   * @param {Number} end\n   * @return {Boolean}\n   */\n\n  hasAnchorBetween(node, start, end) {\n    return (\n      this.anchorOffset <= end &&\n      start <= this.anchorOffset &&\n      this.hasAnchorIn(node)\n    )\n  }\n\n  /**\n   * Check whether the anchor edge of a range is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasAnchorIn(node) {\n    return node.object == 'text'\n      ? node.key == this.anchorKey\n      : this.anchorKey != null && node.hasDescendant(this.anchorKey)\n  }\n\n  /**\n   * Check whether focus point of the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusAtEndOf(node) {\n    const last = getLast(node)\n    return this.focusKey == last.key && this.focusOffset == last.text.length\n  }\n\n  /**\n   * Check whether focus point of the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusAtStartOf(node) {\n    if (this.focusOffset != 0) return false\n    const first = getFirst(node)\n    return this.focusKey == first.key\n  }\n\n  /**\n   * Check whether the focus edge of a range is in a `node` and at an\n   * offset between `start` and `end`.\n   *\n   * @param {Node} node\n   * @param {Number} start\n   * @param {Number} end\n   * @return {Boolean}\n   */\n\n  hasFocusBetween(node, start, end) {\n    return (\n      start <= this.focusOffset &&\n      this.focusOffset <= end &&\n      this.hasFocusIn(node)\n    )\n  }\n\n  /**\n   * Check whether the focus edge of a range is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  hasFocusIn(node) {\n    return node.object == 'text'\n      ? node.key == this.focusKey\n      : this.focusKey != null && node.hasDescendant(this.focusKey)\n  }\n\n  /**\n   * Check whether the range is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtStartOf(node) {\n    return this.isCollapsed && this.hasAnchorAtStartOf(node)\n  }\n\n  /**\n   * Check whether the range is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtEndOf(node) {\n    return this.isCollapsed && this.hasAnchorAtEndOf(node)\n  }\n\n  /**\n   * Focus the range.\n   *\n   * @return {Range}\n   */\n\n  focus() {\n    return this.merge({\n      isFocused: true,\n    })\n  }\n\n  /**\n   * Blur the range.\n   *\n   * @return {Range}\n   */\n\n  blur() {\n    return this.merge({\n      isFocused: false,\n    })\n  }\n\n  /**\n   * Unset the range.\n   *\n   * @return {Range}\n   */\n\n  deselect() {\n    return this.merge({\n      anchorKey: null,\n      anchorOffset: 0,\n      focusKey: null,\n      focusOffset: 0,\n      isFocused: false,\n      isBackward: false,\n    })\n  }\n\n  /**\n   * Flip the range.\n   *\n   * @return {Range}\n   */\n\n  flip() {\n    return this.merge({\n      anchorKey: this.focusKey,\n      anchorOffset: this.focusOffset,\n      focusKey: this.anchorKey,\n      focusOffset: this.anchorOffset,\n      isBackward: this.isBackward == null ? null : !this.isBackward,\n    })\n  }\n\n  /**\n   * Move the anchor offset `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Range}\n   */\n\n  moveAnchor(n = 1) {\n    const { anchorKey, focusKey, focusOffset, isBackward } = this\n    const anchorOffset = this.anchorOffset + n\n    return this.merge({\n      anchorOffset,\n      isBackward:\n        anchorKey == focusKey ? anchorOffset > focusOffset : isBackward,\n    })\n  }\n\n  /**\n   * Move the anchor offset `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Range}\n   */\n\n  moveFocus(n = 1) {\n    const { anchorKey, anchorOffset, focusKey, isBackward } = this\n    const focusOffset = this.focusOffset + n\n    return this.merge({\n      focusOffset,\n      isBackward:\n        focusKey == anchorKey ? anchorOffset > focusOffset : isBackward,\n    })\n  }\n\n  /**\n   * Move the range's anchor point to a `key` and `offset`.\n   *\n   * @param {String} key\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveAnchorTo(key, offset) {\n    const { anchorKey, focusKey, focusOffset, isBackward } = this\n    return this.merge({\n      anchorKey: key,\n      anchorOffset: offset,\n      isBackward:\n        key == focusKey\n          ? offset > focusOffset\n          : key == anchorKey ? isBackward : null,\n    })\n  }\n\n  /**\n   * Move the range's focus point to a `key` and `offset`.\n   *\n   * @param {String} key\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveFocusTo(key, offset) {\n    const { focusKey, anchorKey, anchorOffset, isBackward } = this\n    return this.merge({\n      focusKey: key,\n      focusOffset: offset,\n      isBackward:\n        key == anchorKey\n          ? anchorOffset > offset\n          : key == focusKey ? isBackward : null,\n    })\n  }\n\n  /**\n   * Move the range to `anchorOffset`.\n   *\n   * @param {Number} anchorOffset\n   * @return {Range}\n   */\n\n  moveAnchorOffsetTo(anchorOffset) {\n    return this.merge({\n      anchorOffset,\n      isBackward:\n        this.anchorKey == this.focusKey\n          ? anchorOffset > this.focusOffset\n          : this.isBackward,\n    })\n  }\n\n  /**\n   * Move the range to `focusOffset`.\n   *\n   * @param {Number} focusOffset\n   * @return {Range}\n   */\n\n  moveFocusOffsetTo(focusOffset) {\n    return this.merge({\n      focusOffset,\n      isBackward:\n        this.anchorKey == this.focusKey\n          ? this.anchorOffset > focusOffset\n          : this.isBackward,\n    })\n  }\n\n  /**\n   * Move the range to `anchorOffset` and `focusOffset`.\n   *\n   * @param {Number} anchorOffset\n   * @param {Number} focusOffset (optional)\n   * @return {Range}\n   */\n\n  moveOffsetsTo(anchorOffset, focusOffset = anchorOffset) {\n    return this.moveAnchorOffsetTo(anchorOffset).moveFocusOffsetTo(focusOffset)\n  }\n\n  /**\n   * Move the focus point to the anchor point.\n   *\n   * @return {Range}\n   */\n\n  moveToAnchor() {\n    return this.moveFocusTo(this.anchorKey, this.anchorOffset)\n  }\n\n  /**\n   * Move the anchor point to the focus point.\n   *\n   * @return {Range}\n   */\n\n  moveToFocus() {\n    return this.moveAnchorTo(this.focusKey, this.focusOffset)\n  }\n\n  /**\n   * Move the range's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToStartOf(node) {\n    node = getFirst(node)\n    return this.moveAnchorTo(node.key, 0)\n  }\n\n  /**\n   * Move the range's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToEndOf(node) {\n    node = getLast(node)\n    return this.moveAnchorTo(node.key, node.text.length)\n  }\n\n  /**\n   * Move the range's focus point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToStartOf(node) {\n    node = getFirst(node)\n    return this.moveFocusTo(node.key, 0)\n  }\n\n  /**\n   * Move the range's focus point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToEndOf(node) {\n    node = getLast(node)\n    return this.moveFocusTo(node.key, node.text.length)\n  }\n\n  /**\n   * Move to the entire range of `start` and `end` nodes.\n   *\n   * @param {Node} start\n   * @param {Node} end (optional)\n   * @return {Range}\n   */\n\n  moveToRangeOf(start, end = start) {\n    const range = this.isBackward ? this.flip() : this\n    return range.moveAnchorToStartOf(start).moveFocusToEndOf(end)\n  }\n\n  /**\n   * Normalize the range, relative to a `node`, ensuring that the anchor\n   * and focus nodes of the range always refer to leaf text nodes.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  normalize(node) {\n    const range = this\n    let { anchorKey, anchorOffset, focusKey, focusOffset, isBackward } = range\n\n    const anchorOffsetType = typeof anchorOffset\n    const focusOffsetType = typeof focusOffset\n\n    if (anchorOffsetType != 'number' || focusOffsetType != 'number') {\n      logger.warn(\n        `The range offsets should be numbers, but they were of type \"${anchorOffsetType}\" and \"${focusOffsetType}\".`\n      )\n    }\n\n    // If the range is unset, make sure it is properly zeroed out.\n    if (anchorKey == null || focusKey == null) {\n      return range.merge({\n        anchorKey: null,\n        anchorOffset: 0,\n        focusKey: null,\n        focusOffset: 0,\n        isBackward: false,\n      })\n    }\n\n    // Get the anchor and focus nodes.\n    let anchorNode = node.getDescendant(anchorKey)\n    let focusNode = node.getDescendant(focusKey)\n\n    // If the range is malformed, warn and zero it out.\n    if (!anchorNode || !focusNode) {\n      logger.warn(\n        'The range was invalid and was reset. The range in question was:',\n        range\n      )\n\n      const first = node.getFirstText()\n      return range.merge({\n        anchorKey: first ? first.key : null,\n        anchorOffset: 0,\n        focusKey: first ? first.key : null,\n        focusOffset: 0,\n        isBackward: false,\n      })\n    }\n\n    // If the anchor node isn't a text node, match it to one.\n    if (anchorNode.object != 'text') {\n      logger.warn(\n        'The range anchor was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:',\n        anchorNode\n      )\n\n      const anchorText = anchorNode.getTextAtOffset(anchorOffset)\n      const offset = anchorNode.getOffset(anchorText.key)\n      anchorOffset = anchorOffset - offset\n      anchorNode = anchorText\n    }\n\n    // If the focus node isn't a text node, match it to one.\n    if (focusNode.object != 'text') {\n      logger.warn(\n        'The range focus was set to a Node that is not a Text node. This should not happen and can degrade performance. The node in question was:',\n        focusNode\n      )\n\n      const focusText = focusNode.getTextAtOffset(focusOffset)\n      const offset = focusNode.getOffset(focusText.key)\n      focusOffset = focusOffset - offset\n      focusNode = focusText\n    }\n\n    // If `isBackward` is not set, derive it.\n    if (isBackward == null) {\n      if (anchorNode.key === focusNode.key) {\n        isBackward = anchorOffset > focusOffset\n      } else {\n        isBackward = !node.areDescendantsSorted(anchorNode.key, focusNode.key)\n      }\n    }\n\n    // Merge in any updated properties.\n    return range.merge({\n      anchorKey: anchorNode.key,\n      anchorOffset,\n      focusKey: focusNode.key,\n      focusOffset,\n      isBackward,\n    })\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @return {Object}\n   */\n\n  toJS() {\n    const object = {\n      object: this.object,\n      anchorKey: this.anchorKey,\n      anchorOffset: this.anchorOffset,\n      focusKey: this.focusKey,\n      focusOffset: this.focusOffset,\n      isBackward: this.isBackward,\n      isFocused: this.isFocused,\n      marks:\n        this.marks == null ? null : this.marks.toArray().map(m => m.toJS()),\n      isAtomic: this.isAtomic,\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJSON() {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nRange.prototype[MODEL_TYPES.RANGE] = true\n\n/**\n * Mix in some \"move\" convenience methods.\n */\n\nconst MOVE_METHODS = [\n  ['move', ''],\n  ['move', 'To'],\n  ['move', 'ToStartOf'],\n  ['move', 'ToEndOf'],\n]\n\nMOVE_METHODS.forEach(([p, s]) => {\n  Range.prototype[`${p}${s}`] = function(...args) {\n    return this[`${p}Anchor${s}`](...args)[`${p}Focus${s}`](...args)\n  }\n})\n\n/**\n * Mix in the \"start\", \"end\" and \"edge\" convenience methods.\n */\n\nconst EDGE_METHODS = [\n  ['has', 'AtStartOf', true],\n  ['has', 'AtEndOf', true],\n  ['has', 'Between', true],\n  ['has', 'In', true],\n  ['collapseTo', ''],\n  ['move', ''],\n  ['moveTo', ''],\n  ['move', 'To'],\n  ['move', 'OffsetTo'],\n]\n\nEDGE_METHODS.forEach(([p, s, hasEdge]) => {\n  const anchor = `${p}Anchor${s}`\n  const focus = `${p}Focus${s}`\n\n  Range.prototype[`${p}Start${s}`] = function(...args) {\n    return this.isBackward ? this[focus](...args) : this[anchor](...args)\n  }\n\n  Range.prototype[`${p}End${s}`] = function(...args) {\n    return this.isBackward ? this[anchor](...args) : this[focus](...args)\n  }\n\n  if (hasEdge) {\n    Range.prototype[`${p}Edge${s}`] = function(...args) {\n      return this[anchor](...args) || this[focus](...args)\n    }\n  }\n})\n\n/**\n * Mix in some aliases for convenience / parallelism with the browser APIs.\n */\n\nconst ALIAS_METHODS = [\n  ['collapseTo', 'moveTo'],\n  ['collapseToAnchor', 'moveToAnchor'],\n  ['collapseToFocus', 'moveToFocus'],\n  ['collapseToStart', 'moveToStart'],\n  ['collapseToEnd', 'moveToEnd'],\n  ['collapseToStartOf', 'moveToStartOf'],\n  ['collapseToEndOf', 'moveToEndOf'],\n  ['extend', 'moveFocus'],\n  ['extendTo', 'moveFocusTo'],\n  ['extendToStartOf', 'moveFocusToStartOf'],\n  ['extendToEndOf', 'moveFocusToEndOf'],\n]\n\nALIAS_METHODS.forEach(([alias, method]) => {\n  Range.prototype[alias] = function(...args) {\n    return this[method](...args)\n  }\n})\n\n/**\n * Get the first text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getFirst(node) {\n  return node.object == 'text' ? node : node.getFirstText()\n}\n\n/**\n * Get the last text of a `node`.\n *\n * @param {Node} node\n * @return {Text}\n */\n\nfunction getLast(node) {\n  return node.object == 'text' ? node : node.getLastText()\n}\n\n/**\n * Export.\n *\n * @type {Range}\n */\n\nexport default Range\n","import isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { List, Record, Set } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: new Set(),\n  text: '',\n}\n\n/**\n * Character.\n *\n * @type {Character}\n */\n\nclass Character extends Record(DEFAULTS) {\n  /**\n   * Create a `Character` with `attrs`.\n   *\n   * @param {Object|String|Character} attrs\n   * @return {Character}\n   */\n\n  static create(attrs = {}) {\n    if (Character.isCharacter(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Character.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`Character.create\\` only accepts objects, strings or characters, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Characters` from `elements`.\n   *\n   * @param {String|Array<Object|Character|String>|List<Object|Character|String>} elements\n   * @return {List<Character>}\n   */\n\n  static createList(elements = []) {\n    if (typeof elements == 'string') {\n      elements = elements.split('')\n    }\n\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Character.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts strings, arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Character` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Character}\n   */\n\n  static fromJS(object) {\n    const { text, marks = [] } = object\n\n    if (typeof text != 'string') {\n      throw new Error('`Character.fromJS` requires a block `text` string.')\n    }\n\n    const character = new Character({\n      text,\n      marks: new Set(marks),\n    })\n\n    return character\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Character.fromJS(object)\n  }\n\n  /**\n   * Check if `any` is a `Character`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isCharacter = isType.bind(null, 'CHARACTER')\n\n  /**\n   * Check if `any` is a character list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isCharacterList(any) {\n    return List.isList(any) && any.every(item => Character.isCharacter(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'character'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return a JSON representation of the character.\n   *\n   * @return {Object}\n   */\n\n  toJS() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJS()),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJSON`.\n   */\n\n  toJSON() {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nCharacter.prototype[MODEL_TYPES.CHARACTER] = true\n\n/**\n * Export.\n *\n * @type {Character}\n */\n\nexport default Character\n","import isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { List, Record, Set } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Character from './character'\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: Set(),\n  text: '',\n}\n\n/**\n * Leaf.\n *\n * @type {Leaf}\n */\n\nclass Leaf extends Record(DEFAULTS) {\n  /**\n   * Create a new `Leaf` with `attrs`.\n   *\n   * @param {Object|Leaf} attrs\n   * @return {Leaf}\n   */\n\n  static create(attrs = {}) {\n    if (Leaf.isLeaf(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Leaf.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`Leaf.create\\` only accepts objects, strings or leaves, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a valid List of `Leaf` from `leaves`\n   *\n   * @param {List<Leaf>} leaves\n   * @return {List<Leaf>}\n   */\n\n  static createLeaves(leaves) {\n    if (leaves.size <= 1) return leaves\n\n    let invalid = false\n\n    // TODO: we can make this faster with [List] and then flatten\n    const result = List().withMutations(cache => {\n      // Search from the leaves left end to find invalid node;\n      leaves.findLast((leaf, index) => {\n        const firstLeaf = cache.first()\n\n        // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n        if (firstLeaf) {\n          // If marks equals, then the two leaves can be connected\n          if (firstLeaf.marks.equals(leaf.marks)) {\n            invalid = true\n            cache.set(0, firstLeaf.set('text', `${leaf.text}${firstLeaf.text}`))\n            return\n          }\n\n          // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n          if (firstLeaf.text === '') {\n            invalid = true\n            cache.set(0, leaf)\n            return\n          }\n\n          // If the current leaf is empty, drop the leaf\n          if (leaf.text === '') {\n            invalid = true\n            return\n          }\n        }\n\n        cache.unshift(leaf)\n      })\n    })\n\n    if (!invalid) return leaves\n    return result\n  }\n\n  /**\n   * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n   * Corner Cases:\n   *   1. if offset is smaller than 0, then return [List(), leaves]\n   *   2. if offset is bigger than the text length, then return [leaves, List()]\n   *\n   * @param {List<Leaf> leaves\n   * @return {Array<List<Leaf>>}\n   */\n\n  static splitLeaves(leaves, offset) {\n    if (offset < 0) return [List(), leaves]\n\n    if (leaves.size === 0) {\n      return [List(), List()]\n    }\n\n    let endOffset = 0\n    let index = -1\n    let left, right\n\n    leaves.find(leaf => {\n      index++\n      const startOffset = endOffset\n      const { text } = leaf\n      endOffset += text.length\n\n      if (endOffset < offset) return false\n      if (startOffset > offset) return false\n\n      const length = offset - startOffset\n      left = leaf.set('text', text.slice(0, length))\n      right = leaf.set('text', text.slice(length))\n      return true\n    })\n\n    if (!left) return [leaves, List()]\n\n    if (left.text === '') {\n      if (index === 0) {\n        return [List.of(left), leaves]\n      }\n\n      return [leaves.take(index), leaves.skip(index)]\n    }\n\n    if (right.text === '') {\n      if (index === leaves.size - 1) {\n        return [leaves, List.of(right)]\n      }\n\n      return [leaves.take(index + 1), leaves.skip(index + 1)]\n    }\n\n    return [\n      leaves.take(index).push(left),\n      leaves.skip(index + 1).unshift(right),\n    ]\n  }\n\n  /**\n   * Create a `Leaf` list from `attrs`.\n   *\n   * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n   * @return {List<Leaf>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Leaf.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Leaf.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Leaf` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Leaf}\n   */\n\n  static fromJS(object) {\n    const { text = '', marks = [] } = object\n\n    const leaf = new Leaf({\n      text,\n      marks: Set(marks.map(Mark.fromJS)),\n    })\n\n    return leaf\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Leaf.fromJS(object)\n  }\n\n  /**\n   * Check if `any` is a `Leaf`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeaf = isType.bind(null, 'LEAF')\n\n  /**\n   * Check if `any` is a list of leaves.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeafList(any) {\n    return List.isList(any) && any.every(item => Leaf.isLeaf(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'leaf'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return leaf as a list of characters\n   *\n   * @return {List<Character>}\n   */\n\n  getCharacters() {\n    logger.deprecate(\n      'slate@0.34.0',\n      'The `characters` property of Slate objects is deprecated'\n    )\n\n    const { marks } = this\n    const characters = Character.createList(\n      this.text.split('').map(char => {\n        return Character.create({\n          text: char,\n          marks,\n        })\n      })\n    )\n\n    return characters\n  }\n\n  /**\n   * Update a `mark` at leaf, replace with newMark\n   *\n   * @param {Mark} mark\n   * @param {Mark} newMark\n   * @returns {Leaf}\n   */\n\n  updateMark(mark, newMark) {\n    const { marks } = this\n    if (newMark.equals(mark)) return this\n    if (!marks.has(mark)) return this\n    const newMarks = marks.withMutations(collection => {\n      collection.remove(mark).add(newMark)\n    })\n    return this.set('marks', newMarks)\n  }\n\n  /**\n   * Add a `set` of marks at `index` and `length`.\n   *\n   * @param {Set<Mark>} set\n   * @returns {Text}\n   */\n\n  addMarks(set) {\n    const { marks } = this\n    return this.set('marks', marks.union(set))\n  }\n\n  /**\n   * Remove a `mark` at `index` and `length`.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  removeMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.remove(mark))\n  }\n\n  /**\n   * Return a JSON representation of the leaf.\n   *\n   * @return {Object}\n   */\n\n  toJS() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJS()),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJSON`.\n   */\n\n  toJSON() {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nLeaf.prototype[MODEL_TYPES.LEAF] = true\n\n/**\n * Export.\n *\n * @type {Leaf}\n */\n\nexport default Leaf\n","import isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { List, OrderedSet, Record, Set } from 'immutable'\nimport memoize from 'immutablejs-record-memoize'\n\nimport Leaf from './leaf'\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport generateKey from '../utils/generate-key'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  leaves: List(),\n  key: undefined,\n}\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nclass Text extends Record(DEFAULTS) {\n  /**\n   * Create a new `Text` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Text} attrs\n   * @return {Text}\n   */\n\n  static create(attrs = '') {\n    if (Text.isText(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs == 'string') {\n      attrs = { leaves: [{ text: attrs }] }\n    }\n\n    if (isPlainObject(attrs)) {\n      if (attrs.text) {\n        const { text, marks, key } = attrs\n        attrs = { key, leaves: [{ text, marks }] }\n      }\n\n      return Text.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`Text.create\\` only accepts objects, arrays, strings or texts, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Texts` from `elements`.\n   *\n   * @param {Array<Text|Object>|List<Text|Object>} elements\n   * @return {List<Text>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Text.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Text.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Text` from a JSON `object`.\n   *\n   * @param {Object|Text} object\n   * @return {Text}\n   */\n\n  static fromJS(object) {\n    if (Text.isText(object)) {\n      return object\n    }\n\n    const { key = generateKey() } = object\n    let { leaves = List() } = object\n\n    if (Array.isArray(leaves)) {\n      leaves = List(leaves.map(x => Leaf.create(x)))\n    } else if (List.isList(leaves)) {\n      leaves = leaves.map(x => Leaf.create(x))\n    } else {\n      throw new Error('leaves must be either Array or Immutable.List')\n    }\n\n    const node = new Text({\n      leaves: Leaf.createLeaves(leaves),\n      key,\n    })\n\n    return node\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Text.fromJS(object)\n  }\n\n  /**\n   * Check if `any` is a `Text`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isText = isType.bind(null, 'TEXT')\n\n  /**\n   * Check if `any` is a listof texts.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isTextList(any) {\n    return List.isList(any) && any.every(item => Text.isText(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'text'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Is the node empty?\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    return this.text == ''\n  }\n\n  /**\n   * Get the concatenated text of the node.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getString()\n  }\n\n  /**\n   * Get the concatenated text of the node, cached for text getter\n   *\n   * @returns {String}\n   */\n\n  getString() {\n    return this.leaves.reduce((string, leaf) => string + leaf.text, '')\n  }\n\n  /**\n   * Get the concatenated characters of the node;\n   *\n   * @returns {String}\n   */\n\n  get characters() {\n    return this.leaves.flatMap(x => x.getCharacters())\n  }\n\n  /**\n   * Find the 'first' leaf at offset; By 'first' the alorighthm prefers `endOffset === offset` than `startOffset === offset`\n   * Corner Cases:\n   *   1. if offset is negative, return the first leaf;\n   *   2. if offset is larger than text length, the leaf is null, startOffset, endOffset and index is of the last leaf\n   *\n   * @param {number}\n   * @returns {Object}\n   *   @property {number} startOffset\n   *   @property {number} endOffset\n   *   @property {number} index\n   *   @property {Leaf} leaf\n   */\n\n  searchLeafAtOffset(offset) {\n    let endOffset = 0\n    let startOffset = 0\n    let index = -1\n\n    const leaf = this.leaves.find(l => {\n      index++\n      startOffset = endOffset\n      endOffset = startOffset + l.text.length\n      return endOffset >= offset\n    })\n\n    return {\n      leaf,\n      endOffset,\n      index,\n      startOffset,\n    }\n  }\n\n  /**\n   * Add a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  addMark(index, length, mark) {\n    const marks = Set.of(mark)\n    return this.addMarks(index, length, marks)\n  }\n\n  /**\n   * Add a `set` of marks at `index` and `length`.\n   * Corner Cases:\n   *   1. If empty text, and if length === 0 and index === 0, will make sure the text contain an empty leaf with the given mark.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Set<Mark>} set\n   * @return {Text}\n   */\n\n  addMarks(index, length, set) {\n    if (this.text === '' && length === 0 && index === 0) {\n      const { leaves } = this\n      const first = leaves.first()\n\n      if (!first) {\n        return this.set(\n          'leaves',\n          List.of(Leaf.fromJS({ text: '', marks: set }))\n        )\n      }\n\n      const newFirst = first.addMarks(set)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (this.text === '') return this\n    if (length === 0) return this\n    if (index >= this.text.length) return this\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n    const leaves = before.concat(middle.map(x => x.addMarks(set)), after)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Get the decorations for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Array}\n   */\n\n  getDecorations(schema) {\n    return schema.__getDecorations(this)\n  }\n\n  /**\n   * Derive the leaves for a list of `decorations`.\n   *\n   * @param {Array|Void} decorations (optional)\n   * @return {List<Leaf>}\n   */\n\n  getLeaves(decorations = []) {\n    let { leaves } = this\n    if (leaves.size === 0) return List.of(Leaf.create({}))\n    if (!decorations || decorations.length === 0) return leaves\n    if (this.text.length === 0) return leaves\n    const { key } = this\n\n    decorations.forEach(range => {\n      const { startKey, endKey, startOffset, endOffset, marks } = range\n      const hasStart = startKey == key\n      const hasEnd = endKey == key\n\n      if (hasStart && hasEnd) {\n        const index = hasStart ? startOffset : 0\n        const length = hasEnd ? endOffset - index : this.text.length - index\n\n        if (length < 1) return\n        if (index >= this.text.length) return\n\n        if (index !== 0 || length < this.text.length) {\n          const [before, bundle] = Leaf.splitLeaves(leaves, index)\n          const [middle, after] = Leaf.splitLeaves(bundle, length)\n          leaves = before.concat(middle.map(x => x.addMarks(marks)), after)\n          return\n        }\n      }\n\n      leaves = leaves.map(x => x.addMarks(marks))\n    })\n\n    if (leaves === this.leaves) return leaves\n    return Leaf.createLeaves(leaves)\n  }\n\n  /**\n   * Get all of the active marks on between two offsets\n   * Corner Cases:\n   *   1. if startOffset is equal or bigger than endOffset, then return Set();\n   *   2. If no text is selected between start and end, then return Set()\n   *\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksBetweenOffsets(startOffset, endOffset) {\n    if (startOffset <= 0 && endOffset >= this.text.length) {\n      return this.getActiveMarks()\n    }\n\n    if (startOffset >= endOffset) return Set()\n    // For empty text in a paragraph, use getActiveMarks;\n    if (this.text === '') return this.getActiveMarks()\n\n    let result = null\n    let leafEnd = 0\n\n    this.leaves.forEach(leaf => {\n      const leafStart = leafEnd\n      leafEnd = leafStart + leaf.text.length\n\n      if (leafEnd <= startOffset) return\n      if (leafStart >= endOffset) return false\n\n      if (!result) {\n        result = leaf.marks\n        return\n      }\n\n      result = result.intersect(leaf.marks)\n      if (result && result.size === 0) return false\n      return false\n    })\n\n    return result || Set()\n  }\n\n  /**\n   * Get all of the active marks on the text\n   *\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarks() {\n    if (this.leaves.size === 0) return Set()\n\n    const result = this.leaves.first().marks\n    if (result.size === 0) return result\n\n    return result.withMutations(x => {\n      this.leaves.forEach(c => {\n        x.intersect(c.marks)\n        if (x.size === 0) return false\n      })\n    })\n  }\n\n  /**\n   * Get all of the marks on between two offsets\n   * Corner Cases:\n   *   1. if startOffset is equal or bigger than endOffset, then return Set();\n   *   2. If no text is selected between start and end, then return Set()\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarksBetweenOffsets(startOffset, endOffset) {\n    if (startOffset <= 0 && endOffset >= this.text.length) {\n      return this.getMarks()\n    }\n\n    if (startOffset >= endOffset) return Set()\n    // For empty text in a paragraph, use getActiveMarks;\n    if (this.text === '') return this.getActiveMarks()\n\n    let result = null\n    let leafEnd = 0\n\n    this.leaves.forEach(leaf => {\n      const leafStart = leafEnd\n      leafEnd = leafStart + leaf.text.length\n\n      if (leafEnd <= startOffset) return\n      if (leafStart >= endOffset) return false\n\n      if (!result) {\n        result = leaf.marks\n        return\n      }\n\n      result = result.union(leaf.marks)\n    })\n\n    return result || Set()\n  }\n\n  /**\n   * Get all of the marks on the text.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks on the text as an array\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    if (this.leaves.size === 0) return []\n    const first = this.leaves.first().marks\n    if (this.leaves.size === 1) return first.toArray()\n\n    const result = []\n\n    this.leaves.forEach(leaf => {\n      result.push(leaf.marks.toArray())\n    })\n\n    return Array.prototype.concat.apply(first.toArray(), result)\n  }\n\n  /**\n   * Get the marks on the text at `index`.\n   * Corner Cases:\n   *   1. if no text is before the index, and index !== 0, then return Set()\n   *   2. (for insert after split node or mark at range) if index === 0, and text === '', then return the leaf.marks\n   *   3. if index === 0, text !== '', return Set()\n   *\n   *\n   * @param {Number} index\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtIndex(index) {\n    const { leaf } = this.searchLeafAtOffset(index)\n    if (!leaf) return Set()\n    return leaf.marks\n  }\n\n  /**\n   * Get a node by `key`, to parallel other nodes.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNode(key) {\n    return this.key == key ? this : null\n  }\n\n  /**\n   * Check if the node has a node by `key`, to parallel other nodes.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasNode(key) {\n    return !!this.getNode(key)\n  }\n\n  /**\n   * Insert `text` at `index`.\n   *\n   * @param {Numbder} offset\n   * @param {String} text\n   * @param {Set} marks (optional)\n   * @return {Text}\n   */\n\n  insertText(offset, text, marks) {\n    if (this.text === '') {\n      return this.set('leaves', List.of(Leaf.create({ text, marks })))\n    }\n\n    if (text.length === 0) return this\n    if (!marks) marks = Set()\n\n    const { startOffset, leaf, index } = this.searchLeafAtOffset(offset)\n    const delta = offset - startOffset\n    const beforeText = leaf.text.slice(0, delta)\n    const afterText = leaf.text.slice(delta)\n    const { leaves } = this\n\n    if (leaf.marks.equals(marks)) {\n      return this.set(\n        'leaves',\n        leaves.set(index, leaf.set('text', beforeText + text + afterText))\n      )\n    }\n\n    const nextLeaves = leaves.splice(\n      index,\n      1,\n      leaf.set('text', beforeText),\n      Leaf.create({ text, marks }),\n      leaf.set('text', afterText)\n    )\n\n    return this.setLeaves(nextLeaves)\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Text}\n   */\n\n  regenerateKey() {\n    const key = generateKey()\n    return this.set('key', key)\n  }\n\n  /**\n   * Remove a `mark` at `index` and `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  removeMark(index, length, mark) {\n    if (this.text === '' && index === 0 && length === 0) {\n      const first = this.leaves.first()\n      if (!first) return this\n      const newFirst = first.removeMark(mark)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (length <= 0) return this\n    if (index >= this.text.length) return this\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n    const leaves = before.concat(middle.map(x => x.removeMark(mark)), after)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Remove text from the text node at `start` for `length`.\n   *\n   * @param {Number} start\n   * @param {Number} length\n   * @return {Text}\n   */\n\n  removeText(start, length) {\n    if (length <= 0) return this\n    if (start >= this.text.length) return this\n\n    // PERF: For simple backspace, we can operate directly on the leaf\n    if (length === 1) {\n      const { leaf, index, startOffset } = this.searchLeafAtOffset(start + 1)\n      const offset = start - startOffset\n\n      if (leaf) {\n        if (leaf.text.length === 1) {\n          const leaves = this.leaves.remove(index)\n          return this.setLeaves(leaves)\n        }\n\n        const beforeText = leaf.text.slice(0, offset)\n        const afterText = leaf.text.slice(offset + length)\n        const text = beforeText + afterText\n\n        if (text.length > 0) {\n          return this.set(\n            'leaves',\n            this.leaves.set(index, leaf.set('text', text))\n          )\n        }\n      }\n    }\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, start)\n    const after = Leaf.splitLeaves(bundle, length)[1]\n    const leaves = Leaf.createLeaves(before.concat(after))\n\n    if (leaves.size === 1) {\n      const first = leaves.first()\n\n      if (first.text === '') {\n        return this.set(\n          'leaves',\n          List.of(first.set('marks', this.getActiveMarks()))\n        )\n      }\n    }\n\n    return this.set('leaves', leaves)\n  }\n\n  /**\n   * Return a JSON representation of the text.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJS(options = {}) {\n    const object = {\n      object: this.object,\n      leaves: this.getLeaves()\n        .toArray()\n        .map(r => r.toJS()),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJSON`.\n   */\n\n  toJSON(options) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS(options)\n  }\n\n  /**\n   * Update a `mark` at `index` and `length` with `properties`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Text}\n   */\n\n  updateMark(index, length, mark, properties) {\n    const newMark = mark.merge(properties)\n\n    if (this.text === '' && length === 0 && index === 0) {\n      const { leaves } = this\n      const first = leaves.first()\n      if (!first) return this\n      const newFirst = first.updateMark(mark, newMark)\n      if (newFirst === first) return this\n      return this.set('leaves', List.of(newFirst))\n    }\n\n    if (length <= 0) return this\n    if (index >= this.text.length) return this\n\n    const [before, bundle] = Leaf.splitLeaves(this.leaves, index)\n    const [middle, after] = Leaf.splitLeaves(bundle, length)\n\n    const leaves = before.concat(\n      middle.map(x => x.updateMark(mark, newMark)),\n      after\n    )\n\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Split this text and return two different texts\n   * @param {Number} position\n   * @returns {Array<Text>}\n   */\n\n  splitText(offset) {\n    const splitted = Leaf.splitLeaves(this.leaves, offset)\n    const one = this.set('leaves', splitted[0])\n    const two = this.set('leaves', splitted[1]).regenerateKey()\n    return [one, two]\n  }\n\n  /**\n   * merge this text and another text at the end\n   * @param {Text} text\n   * @returns {Text}\n   */\n\n  mergeText(text) {\n    const leaves = this.leaves.concat(text.leaves)\n    return this.setLeaves(leaves)\n  }\n\n  /**\n   * Validate the text node against a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Object|Void}\n   */\n\n  validate(schema) {\n    return schema.validateNode(this)\n  }\n\n  /**\n   * Get the first invalid descendant\n   * PERF: Do not cache this method; because it can cause cycle reference\n   *\n   * @param {Schema} schema\n   * @returns {Text|Null}\n   */\n\n  getFirstInvalidDescendant(schema) {\n    return this.validate(schema) ? this : null\n  }\n\n  /**\n   * Set leaves with normalized `leaves`\n   *\n   * @param {Schema} schema\n   * @returns {Text|Null}\n   */\n\n  setLeaves(leaves) {\n    const result = Leaf.createLeaves(leaves)\n\n    if (result.size === 1) {\n      const first = result.first()\n\n      if (!first.marks || first.marks.size === 0) {\n        if (first.text === '') {\n          return this.set('leaves', List())\n        }\n      }\n    }\n\n    return this.set('leaves', Leaf.createLeaves(leaves))\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nText.prototype[MODEL_TYPES.TEXT] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Text.prototype, [\n  'getDecorations',\n  'getActiveMarks',\n  'getMarks',\n  'getMarksAsArray',\n  'validate',\n  'getString',\n])\n\n/**\n * Export.\n *\n * @type {Text}\n */\n\nexport default Text\n","import direction from 'direction'\nimport isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { List, OrderedSet, Set } from 'immutable'\nimport memoize from 'immutablejs-record-memoize'\n\nimport Data from './data'\nimport Block from './block'\nimport Inline from './inline'\nimport Document from './document'\nimport { isType } from '../constants/model-types'\nimport Range from './range'\nimport Text from './text'\nimport generateKey from '../utils/generate-key'\n\n/**\n * Node.\n *\n * And interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Node}\n */\n\nclass Node {\n  /**\n   * Create a new `Node` with `attrs`.\n   *\n   * @param {Object|Node} attrs\n   * @return {Node}\n   */\n\n  static create(attrs = {}) {\n    if (Node.isNode(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      let { object } = attrs\n\n      if (!object && attrs.kind) {\n        logger.deprecate(\n          'slate@0.32.0',\n          'The `kind` property of Slate objects has been renamed to `object`.'\n        )\n\n        object = attrs.kind\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.create(attrs)\n        case 'document':\n          return Document.create(attrs)\n        case 'inline':\n          return Inline.create(attrs)\n        case 'text':\n          return Text.create(attrs)\n\n        default: {\n          throw new Error('`Node.create` requires a `object` string.')\n        }\n      }\n    }\n\n    throw new Error(\n      `\\`Node.create\\` only accepts objects or nodes but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Nodes` from an array.\n   *\n   * @param {Array<Object|Node>} elements\n   * @return {List<Node>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = List(elements.map(Node.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Node.createList\\` only accepts lists or arrays, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable node properties from `attrs`.\n   *\n   * @param {Object|String|Node} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n      return {\n        data: attrs.data,\n        isVoid: attrs.isVoid,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs == 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      if ('isVoid' in attrs) props.isVoid = attrs.isVoid\n      return props\n    }\n\n    throw new Error(\n      `\\`Node.createProperties\\` only accepts objects, strings, blocks or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Node` from a JSON `value`.\n   *\n   * @param {Object} value\n   * @return {Node}\n   */\n\n  static fromJSON(value) {\n    let { object } = value\n\n    if (!object && value.kind) {\n      logger.deprecate(\n        'slate@0.32.0',\n        'The `kind` property of Slate objects has been renamed to `object`.'\n      )\n\n      object = value.kind\n    }\n\n    switch (object) {\n      case 'block':\n        return Block.fromJS(value)\n      case 'document':\n        return Document.fromJS(value)\n      case 'inline':\n        return Inline.fromJS(value)\n      case 'text':\n        return Text.fromJS(value)\n\n      default: {\n        throw new Error(\n          `\\`Node.fromJS\\` requires an \\`object\\` of either 'block', 'document', 'inline' or 'text', but you passed: ${value}`\n        )\n      }\n    }\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Node.fromJSON\n\n  /**\n   * Check if `any` is a `Node`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNode(any) {\n    return !!['BLOCK', 'DOCUMENT', 'INLINE', 'TEXT'].find(type =>\n      isType(type, any)\n    )\n  }\n\n  /**\n   * Check if `any` is a list of nodes.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNodeList(any) {\n    return List.isList(any) && any.every(item => Node.isNode(item))\n  }\n\n  /**\n   * True if the node has both descendants in that order, false otherwise. The\n   * order is depth-first, post-order.\n   *\n   * @param {String} first\n   * @param {String} second\n   * @return {Boolean}\n   */\n\n  areDescendantsSorted(first, second) {\n    first = assertKey(first)\n    second = assertKey(second)\n\n    const keys = this.getKeysAsArray()\n    const firstIndex = keys.indexOf(first)\n    const secondIndex = keys.indexOf(second)\n    if (firstIndex == -1 || secondIndex == -1) return null\n\n    return firstIndex < secondIndex\n  }\n\n  /**\n   * Assert that a node has a child by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertChild(key) {\n    const child = this.getChild(key)\n\n    if (!child) {\n      key = assertKey(key)\n      throw new Error(`Could not find a child node with key \"${key}\".`)\n    }\n\n    return child\n  }\n\n  /**\n   * Assert that a node has a descendant by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertDescendant(key) {\n    const descendant = this.getDescendant(key)\n\n    if (!descendant) {\n      key = assertKey(key)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    return descendant\n  }\n\n  /**\n   * Assert that a node's tree has a node by `key` and return it.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  assertNode(key) {\n    const node = this.getNode(key)\n\n    if (!node) {\n      key = assertKey(key)\n      throw new Error(`Could not find a node with key \"${key}\".`)\n    }\n\n    return node\n  }\n\n  /**\n   * Assert that a node exists at `path` and return it.\n   *\n   * @param {Array} path\n   * @return {Node}\n   */\n\n  assertPath(path) {\n    const descendant = this.getDescendantAtPath(path)\n\n    if (!descendant) {\n      throw new Error(`Could not find a descendant at path \"${path}\".`)\n    }\n\n    return descendant\n  }\n\n  /**\n   * Recursively filter all descendant nodes with `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {List<Node>}\n   */\n\n  filterDescendants(iterator) {\n    const matches = []\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) matches.push(node)\n    })\n\n    return List(matches)\n  }\n\n  /**\n   * Recursively find all descendant nodes by `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  findDescendant(iterator) {\n    let found = null\n\n    this.forEachDescendant((node, i, nodes) => {\n      if (iterator(node, i, nodes)) {\n        found = node\n        return false\n      }\n    })\n\n    return found\n  }\n\n  /**\n   * Recursively iterate over all descendant nodes with `iterator`. If the\n   * iterator returns false it will break the loop.\n   *\n   * @param {Function} iterator\n   */\n\n  forEachDescendant(iterator) {\n    let ret\n\n    this.nodes.forEach((child, i, nodes) => {\n      if (iterator(child, i, nodes) === false) {\n        ret = false\n        return false\n      }\n\n      if (child.object != 'text') {\n        ret = child.forEachDescendant(iterator)\n        return ret\n      }\n    })\n\n    return ret\n  }\n\n  /**\n   * Get the path of ancestors of a descendant node by `key`.\n   *\n   * @param {String|Node} key\n   * @return {List<Node>|Null}\n   */\n\n  getAncestors(key) {\n    key = assertKey(key)\n\n    if (key == this.key) return List()\n    if (this.hasChild(key)) return List([this])\n\n    let ancestors\n\n    this.nodes.find(node => {\n      if (node.object == 'text') return false\n      ancestors = node.getAncestors(key)\n      return ancestors\n    })\n\n    if (ancestors) {\n      return ancestors.unshift(this)\n    } else {\n      return null\n    }\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocks() {\n    const array = this.getBlocksAsArray()\n    return new List(array)\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocksAsArray() {\n    return this.nodes.reduce((array, child) => {\n      if (child.object != 'block') return array\n      if (!child.isLeafBlock()) return array.concat(child.getBlocksAsArray())\n      array.push(child)\n      return array\n    }, [])\n  }\n\n  /**\n   * Get the leaf block descendants in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getBlocksAtRange(range) {\n    const array = this.getBlocksAtRangeAsArray(range)\n    // Eliminate duplicates by converting to an `OrderedSet` first.\n    return new List(new OrderedSet(array))\n  }\n\n  /**\n   * Get the leaf block descendants in a `range` as an array\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getBlocksAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n\n    const { startKey, endKey } = range\n    const startBlock = this.getClosestBlock(startKey)\n\n    // PERF: the most common case is when the range is in a single block node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey == endKey) return [startBlock]\n\n    const endBlock = this.getClosestBlock(endKey)\n    const blocks = this.getBlocksAsArray()\n    const start = blocks.indexOf(startBlock)\n    const end = blocks.indexOf(endBlock)\n    return blocks.slice(start, end + 1)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getBlocksByType(type) {\n    const array = this.getBlocksByTypeAsArray(type)\n    return new List(array)\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type` as an array\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getBlocksByTypeAsArray(type) {\n    return this.nodes.reduce((array, node) => {\n      if (node.object != 'block') {\n        return array\n      } else if (node.isLeafBlock() && node.type == type) {\n        array.push(node)\n        return array\n      } else {\n        return array.concat(node.getBlocksByTypeAsArray(type))\n      }\n    }, [])\n  }\n\n  /**\n   * Get all of the characters for every text node.\n   *\n   * @return {List<Character>}\n   */\n\n  getCharacters() {\n    return this.getTexts().flatMap(t => t.characters)\n  }\n\n  /**\n   * Get a list of the characters in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Character>}\n   */\n\n  getCharactersAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return List()\n    const { startKey, endKey, startOffset, endOffset } = range\n\n    if (startKey === endKey) {\n      const endText = this.getDescendant(endKey)\n      return endText.characters.slice(startOffset, endOffset)\n    }\n\n    return this.getTextsAtRange(range).flatMap(t => {\n      if (t.key === startKey) {\n        return t.characters.slice(startOffset)\n      }\n\n      if (t.key === endKey) {\n        return t.characters.slice(0, endOffset)\n      }\n      return t.characters\n    })\n  }\n\n  /**\n   * Get a child node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getChild(key) {\n    key = assertKey(key)\n    return this.nodes.find(node => node.key == key)\n  }\n\n  /**\n   * Get closest parent of node by `key` that matches `iterator`.\n   *\n   * @param {String} key\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getClosest(key, iterator) {\n    key = assertKey(key)\n    const ancestors = this.getAncestors(key)\n\n    if (!ancestors) {\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    // Exclude this node itself.\n    return ancestors.rest().findLast(iterator)\n  }\n\n  /**\n   * Get the closest block parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestBlock(key) {\n    return this.getClosest(key, parent => parent.object == 'block')\n  }\n\n  /**\n   * Get the closest inline parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestInline(key) {\n    return this.getClosest(key, parent => parent.object == 'inline')\n  }\n\n  /**\n   * Get the closest void parent of a `node`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getClosestVoid(key) {\n    return this.getClosest(key, parent => parent.isVoid)\n  }\n\n  /**\n   * Get the common ancestor of nodes `one` and `two` by keys.\n   *\n   * @param {String} one\n   * @param {String} two\n   * @return {Node}\n   */\n\n  getCommonAncestor(one, two) {\n    one = assertKey(one)\n    two = assertKey(two)\n\n    if (one == this.key) return this\n    if (two == this.key) return this\n\n    this.assertDescendant(one)\n    this.assertDescendant(two)\n    let ancestors = new List()\n    let oneParent = this.getParent(one)\n    let twoParent = this.getParent(two)\n\n    while (oneParent) {\n      ancestors = ancestors.push(oneParent)\n      oneParent = this.getParent(oneParent.key)\n    }\n\n    while (twoParent) {\n      if (ancestors.includes(twoParent)) return twoParent\n      twoParent = this.getParent(twoParent.key)\n    }\n  }\n\n  /**\n   * Get the decorations for the node from a `stack`.\n   *\n   * @param {Stack} stack\n   * @return {List}\n   */\n\n  getDecorations(stack) {\n    const decorations = stack.find('decorateNode', this)\n    const list = Range.createList(decorations || [])\n    return list\n  }\n\n  /**\n   * Get the depth of a child node by `key`, with optional `startAt`.\n   *\n   * @param {String} key\n   * @param {Number} startAt (optional)\n   * @return {Number} depth\n   */\n\n  getDepth(key, startAt = 1) {\n    this.assertDescendant(key)\n    if (this.hasChild(key)) return startAt\n    return this.getFurthestAncestor(key).getDepth(key, startAt + 1)\n  }\n\n  /**\n   * Get a descendant node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getDescendant(key) {\n    key = assertKey(key)\n    let descendantFound = null\n\n    const found = this.nodes.find(node => {\n      if (node.key === key) {\n        return node\n      } else if (node.object !== 'text') {\n        descendantFound = node.getDescendant(key)\n        return descendantFound\n      } else {\n        return false\n      }\n    })\n\n    return descendantFound || found\n  }\n\n  /**\n   * Get a descendant by `path`.\n   *\n   * @param {Array} path\n   * @return {Node|Null}\n   */\n\n  getDescendantAtPath(path) {\n    let descendant = this\n\n    for (const index of path) {\n      if (!descendant) return\n      if (!descendant.nodes) return\n      descendant = descendant.nodes.get(index)\n    }\n\n    return descendant\n  }\n\n  /**\n   * Get the first child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getFirstText() {\n    let descendantFound = null\n\n    const found = this.nodes.find(node => {\n      if (node.object == 'text') return true\n      descendantFound = node.getFirstText()\n      return descendantFound\n    })\n\n    return descendantFound || found\n  }\n\n  /**\n   * Get a fragment of the node at a `range`.\n   *\n   * @param {Range} range\n   * @return {Document}\n   */\n\n  getFragmentAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return Document.create()\n\n    let node = this\n\n    // Make sure the children exist.\n    const { startKey, startOffset, endKey, endOffset } = range\n    const startText = node.assertDescendant(startKey)\n    const endText = node.assertDescendant(endKey)\n\n    // Split at the start and end.\n    let child = startText\n    let previous\n    let parent\n\n    while ((parent = node.getParent(child.key))) {\n      const index = parent.nodes.indexOf(child)\n      const position =\n        child.object == 'text' ? startOffset : child.nodes.indexOf(previous)\n\n      parent = parent.splitNode(index, position)\n      node = node.updateNode(parent)\n      previous = parent.nodes.get(index + 1)\n      child = parent\n    }\n\n    child = startKey == endKey ? node.getNextText(startKey) : endText\n\n    while ((parent = node.getParent(child.key))) {\n      const index = parent.nodes.indexOf(child)\n      const position =\n        child.object == 'text'\n          ? startKey == endKey ? endOffset - startOffset : endOffset\n          : child.nodes.indexOf(previous)\n\n      parent = parent.splitNode(index, position)\n      node = node.updateNode(parent)\n      previous = parent.nodes.get(index + 1)\n      child = parent\n    }\n\n    // Get the start and end nodes.\n    const startNode = node.getNextSibling(\n      node.getFurthestAncestor(startKey).key\n    )\n    const endNode =\n      startKey == endKey\n        ? node.getNextSibling(\n            node.getNextSibling(node.getFurthestAncestor(endKey).key).key\n          )\n        : node.getNextSibling(node.getFurthestAncestor(endKey).key)\n\n    // Get children range of nodes from start to end nodes\n    const startIndex = node.nodes.indexOf(startNode)\n    const endIndex = node.nodes.indexOf(endNode)\n    const nodes = node.nodes.slice(startIndex, endIndex)\n\n    // Return a new document fragment.\n    return Document.create({ nodes })\n  }\n\n  /**\n   * Get the furthest parent of a node by `key` that matches an `iterator`.\n   *\n   * @param {String} key\n   * @param {Function} iterator\n   * @return {Node|Null}\n   */\n\n  getFurthest(key, iterator) {\n    const ancestors = this.getAncestors(key)\n\n    if (!ancestors) {\n      key = assertKey(key)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    // Exclude this node itself\n    return ancestors.rest().find(iterator)\n  }\n\n  /**\n   * Get the furthest block parent of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestBlock(key) {\n    return this.getFurthest(key, node => node.object == 'block')\n  }\n\n  /**\n   * Get the furthest inline parent of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestInline(key) {\n    return this.getFurthest(key, node => node.object == 'inline')\n  }\n\n  /**\n   * Get the furthest ancestor of a node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestAncestor(key) {\n    key = assertKey(key)\n    return this.nodes.find(node => {\n      if (node.key == key) return true\n      if (node.object == 'text') return false\n      return node.hasDescendant(key)\n    })\n  }\n\n  /**\n   * Get the furthest ancestor of a node by `key` that has only one child.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getFurthestOnlyChildAncestor(key) {\n    const ancestors = this.getAncestors(key)\n\n    if (!ancestors) {\n      key = assertKey(key)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n    }\n\n    const result = ancestors\n      // Skip this node...\n      .shift()\n      // Take parents until there are more than one child...\n      .reverse()\n      .takeUntil(p => p.nodes.size > 1)\n      // And pick the highest.\n      .last()\n    if (!result) return null\n    return result\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlines() {\n    const array = this.getInlinesAsArray()\n    return new List(array)\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node, as an array.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlinesAsArray() {\n    let array = []\n\n    this.nodes.forEach(child => {\n      if (child.object == 'text') return\n\n      if (child.isLeafInline()) {\n        array.push(child)\n      } else {\n        array = array.concat(child.getInlinesAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getInlinesAtRange(range) {\n    const array = this.getInlinesAtRangeAsArray(range)\n    // Remove duplicates by converting it to an `OrderedSet` first.\n    return new List(new OrderedSet(array))\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getInlinesAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n\n    return this.getTextsAtRangeAsArray(range)\n      .map(text => this.getClosestInline(text.key))\n      .filter(exists => exists)\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getInlinesByType(type) {\n    const array = this.getInlinesByTypeAsArray(type)\n    return new List(array)\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getInlinesByTypeAsArray(type) {\n    return this.nodes.reduce((inlines, node) => {\n      if (node.object == 'text') {\n        return inlines\n      } else if (node.isLeafInline() && node.type == type) {\n        inlines.push(node)\n        return inlines\n      } else {\n        return inlines.concat(node.getInlinesByTypeAsArray(type))\n      }\n    }, [])\n  }\n\n  /**\n   * Return a set of all keys in the node as an array.\n   *\n   * @return {Array<String>}\n   */\n\n  getKeysAsArray() {\n    const keys = []\n\n    this.forEachDescendant(desc => {\n      keys.push(desc.key)\n    })\n\n    return keys\n  }\n\n  /**\n   * Return a set of all keys in the node.\n   *\n   * @return {Set<String>}\n   */\n\n  getKeys() {\n    const keys = this.getKeysAsArray()\n    return new Set(keys)\n  }\n\n  /**\n   * Get the last child text node.\n   *\n   * @return {Node|Null}\n   */\n\n  getLastText() {\n    let descendantFound = null\n\n    const found = this.nodes.findLast(node => {\n      if (node.object == 'text') return true\n      descendantFound = node.getLastText()\n      return descendantFound\n    })\n\n    return descendantFound || found\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {Set<Mark>}\n   */\n\n  getMarks() {\n    const array = this.getMarksAsArray()\n    return new Set(array)\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarks() {\n    const array = this.getMarksAsArray()\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks as an array.\n   *\n   * @return {Array}\n   */\n\n  getMarksAsArray() {\n    // PERF: use only one concat rather than multiple concat\n    // becuase one concat is faster\n    const result = []\n\n    this.nodes.forEach(node => {\n      result.push(node.getMarksAsArray())\n    })\n    return Array.prototype.concat.apply([], result)\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getMarksAtRange(range) {\n    return new Set(this.getOrderedMarksAtRange(range))\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getInsertMarksAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return Set()\n\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use key and offset as proxies for cache\n      return this.getMarksAtPosition(range.startKey, range.startOffset)\n    }\n\n    const { startKey, startOffset } = range\n    const text = this.getDescendant(startKey)\n    return text.getMarksAtIndex(startOffset + 1)\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return OrderedSet()\n\n    if (range.isCollapsed) {\n      // PERF: range is not cachable, use key and offset as proxies for cache\n      return this.getMarksAtPosition(range.startKey, range.startOffset)\n    }\n\n    const { startKey, startOffset, endKey, endOffset } = range\n    return this.getOrderedMarksBetweenPositions(\n      startKey,\n      startOffset,\n      endKey,\n      endOffset\n    )\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   * PERF: arguments use key and offset for utilizing cache\n   *\n   * @param {string} startKey\n   * @param {number} startOffset\n   * @param {string} endKey\n   * @param {number} endOffset\n   * @returns {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksBetweenPositions(startKey, startOffset, endKey, endOffset) {\n    if (startKey === endKey) {\n      const startText = this.getDescendant(startKey)\n      return startText.getMarksBetweenOffsets(startOffset, endOffset)\n    }\n\n    const texts = this.getTextsBetweenPositionsAsArray(startKey, endKey)\n\n    return OrderedSet().withMutations(result => {\n      texts.forEach(text => {\n        if (text.key === startKey) {\n          result.union(\n            text.getMarksBetweenOffsets(startOffset, text.text.length)\n          )\n        } else if (text.key === endKey) {\n          result.union(text.getMarksBetweenOffsets(0, endOffset))\n        } else {\n          result.union(text.getMarks())\n        }\n      })\n    })\n  }\n\n  /**\n   * Get a set of the active marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return Set()\n\n    if (range.isCollapsed) {\n      const { startKey, startOffset } = range\n      return this.getMarksAtPosition(startKey, startOffset).toSet()\n    }\n\n    let { startKey, endKey, startOffset, endOffset } = range\n    let startText = this.getDescendant(startKey)\n\n    if (startKey !== endKey) {\n      while (startKey !== endKey && endOffset === 0) {\n        const endText = this.getPreviousText(endKey)\n        endKey = endText.key\n        endOffset = endText.text.length\n      }\n\n      while (startKey !== endKey && startOffset === startText.text.length) {\n        startText = this.getNextText(startKey)\n        startKey = startText.key\n        startOffset = 0\n      }\n    }\n\n    if (startKey === endKey) {\n      return startText.getActiveMarksBetweenOffsets(startOffset, endOffset)\n    }\n\n    const startMarks = startText.getActiveMarksBetweenOffsets(\n      startOffset,\n      startText.text.length\n    )\n    if (startMarks.size === 0) return Set()\n    const endText = this.getDescendant(endKey)\n    const endMarks = endText.getActiveMarksBetweenOffsets(0, endOffset)\n    let marks = startMarks.intersect(endMarks)\n    // If marks is already empty, the active marks is empty\n    if (marks.size === 0) return marks\n\n    let text = this.getNextText(startKey)\n\n    while (text.key !== endKey) {\n      if (text.text.length !== 0) {\n        marks = marks.intersect(text.getActiveMarks())\n        if (marks.size === 0) return Set()\n      }\n\n      text = this.getNextText(text.key)\n    }\n    return marks\n  }\n\n  /**\n   * Get a set of marks in a `position`, the equivalent of a collapsed range\n   *\n   * @param {string} key\n   * @param {number} offset\n   * @return {Set}\n   */\n\n  getMarksAtPosition(key, offset) {\n    const text = this.getDescendant(key)\n    const currentMarks = text.getMarksAtIndex(offset)\n    if (offset !== 0) return currentMarks\n    const closestBlock = this.getClosestBlock(key)\n\n    if (closestBlock.text === '') {\n      // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n      return currentMarks\n    }\n\n    const previous = this.getPreviousText(key)\n    if (!previous) return Set()\n\n    if (closestBlock.hasDescendant(previous.key)) {\n      return previous.getMarksAtIndex(previous.text.length)\n    }\n\n    return currentMarks\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {Set<Mark>}\n   */\n\n  getMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return new Set(array)\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {OrderedSet<Mark>}\n   */\n\n  getOrderedMarksByType(type) {\n    const array = this.getMarksByTypeAsArray(type)\n    return new OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks that match a `type` as an array.\n   *\n   * @param {String} type\n   * @return {Array}\n   */\n\n  getMarksByTypeAsArray(type) {\n    return this.nodes.reduce((array, node) => {\n      return node.object == 'text'\n        ? array.concat(node.getMarksAsArray().filter(m => m.type == type))\n        : array.concat(node.getMarksByTypeAsArray(type))\n    }, [])\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextBlock(key) {\n    const child = this.assertDescendant(key)\n    let last\n\n    if (child.object == 'block') {\n      last = child.getLastText()\n    } else {\n      const block = this.getClosestBlock(key)\n      last = block.getLastText()\n    }\n\n    const next = this.getNextText(last.key)\n    if (!next) return null\n\n    return this.getClosestBlock(next.key)\n  }\n\n  /**\n   * Get the node after a descendant by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextSibling(key) {\n    key = assertKey(key)\n\n    const parent = this.getParent(key)\n    const after = parent.nodes.skipUntil(child => child.key == key)\n\n    if (after.size == 0) {\n      throw new Error(`Could not find a child node with key \"${key}\".`)\n    }\n    return after.get(1)\n  }\n\n  /**\n   * Get the text node after a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNextText(key) {\n    key = assertKey(key)\n    return this.getTexts()\n      .skipUntil(text => text.key == key)\n      .get(1)\n  }\n\n  /**\n   * Get a node in the tree by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getNode(key) {\n    key = assertKey(key)\n    return this.key == key ? this : this.getDescendant(key)\n  }\n\n  /**\n   * Get a node in the tree by `path`.\n   *\n   * @param {Array} path\n   * @return {Node|Null}\n   */\n\n  getNodeAtPath(path) {\n    return path.length ? this.getDescendantAtPath(path) : this\n  }\n\n  /**\n   * Get the offset for a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Number}\n   */\n\n  getOffset(key) {\n    this.assertDescendant(key)\n\n    // Calculate the offset of the nodes before the highest child.\n    const child = this.getFurthestAncestor(key)\n    const offset = this.nodes\n      .takeUntil(n => n == child)\n      .reduce((memo, n) => memo + n.text.length, 0)\n\n    // Recurse if need be.\n    return this.hasChild(key) ? offset : offset + child.getOffset(key)\n  }\n\n  /**\n   * Get the offset from a `range`.\n   *\n   * @param {Range} range\n   * @return {Number}\n   */\n\n  getOffsetAtRange(range) {\n    range = range.normalize(this)\n\n    if (range.isUnset) {\n      throw new Error('The range cannot be unset to calculcate its offset.')\n    }\n\n    if (range.isExpanded) {\n      throw new Error('The range must be collapsed to calculcate its offset.')\n    }\n\n    const { startKey, startOffset } = range\n    return this.getOffset(startKey) + startOffset\n  }\n\n  /**\n   * Get the parent of a child node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getParent(key) {\n    if (this.hasChild(key)) return this\n\n    let node = null\n\n    this.nodes.find(child => {\n      if (child.object == 'text') {\n        return false\n      } else {\n        node = child.getParent(key)\n        return node\n      }\n    })\n\n    return node\n  }\n\n  /**\n   * Get the path of a descendant node by `key`.\n   *\n   * @param {String|Node} key\n   * @return {Array}\n   */\n\n  getPath(key) {\n    let child = this.assertNode(key)\n    const ancestors = this.getAncestors(key)\n    const path = []\n\n    ancestors.reverse().forEach(ancestor => {\n      const index = ancestor.nodes.indexOf(child)\n      path.unshift(index)\n      child = ancestor\n    })\n\n    return path\n  }\n\n  /**\n   * Refind the path of node if path is changed.\n   *\n   * @param {Array} path\n   * @param {String} key\n   * @return {Array}\n   */\n\n  refindPath(path, key) {\n    const node = this.getDescendantAtPath(path)\n\n    if (node && node.key === key) {\n      return path\n    }\n\n    return this.getPath(key)\n  }\n\n  /**\n   *\n   * Refind the node with the same node.key after change.\n   *\n   * @param {Array} path\n   * @param {String} key\n   * @return {Node|Void}\n   */\n\n  refindNode(path, key) {\n    const node = this.getDescendantAtPath(path)\n\n    if (node && node.key === key) {\n      return node\n    }\n\n    return this.getDescendant(key)\n  }\n\n  /**\n   * Get the placeholder for the node from a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Component|Void}\n   */\n\n  getPlaceholder(schema) {\n    return schema.__getPlaceholder(this)\n  }\n\n  /**\n   * Get the block node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousBlock(key) {\n    const child = this.assertDescendant(key)\n    let first\n\n    if (child.object == 'block') {\n      first = child.getFirstText()\n    } else {\n      const block = this.getClosestBlock(key)\n      first = block.getFirstText()\n    }\n\n    const previous = this.getPreviousText(first.key)\n    if (!previous) return null\n\n    return this.getClosestBlock(previous.key)\n  }\n\n  /**\n   * Get the node before a descendant node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousSibling(key) {\n    key = assertKey(key)\n    const parent = this.getParent(key)\n    const before = parent.nodes.takeUntil(child => child.key == key)\n\n    if (before.size == parent.nodes.size) {\n      throw new Error(`Could not find a child node with key \"${key}\".`)\n    }\n\n    return before.last()\n  }\n\n  /**\n   * Get the text node before a descendant text node by `key`.\n   *\n   * @param {String} key\n   * @return {Node|Null}\n   */\n\n  getPreviousText(key) {\n    key = assertKey(key)\n    return this.getTexts()\n      .takeUntil(text => text.key == key)\n      .last()\n  }\n\n  /**\n   * Get the indexes of the selection for a `range`, given an extra flag for\n   * whether the node `isSelected`, to determine whether not finding matches\n   * means everything is selected or nothing is.\n   *\n   * @param {Range} range\n   * @param {Boolean} isSelected\n   * @return {Object|Null}\n   */\n\n  getSelectionIndexes(range, isSelected = true) {\n    const { startKey, endKey } = range\n\n    // PERF: if we're not selected, we can exit early.\n    if (!isSelected) {\n      return null\n    }\n\n    // if we've been given an invalid selection we can exit early.\n    if (range.isUnset) {\n      return null\n    }\n\n    // PERF: if the start and end keys are the same, just check for the child\n    // that contains that single key.\n    if (startKey == endKey) {\n      const child = this.getFurthestAncestor(startKey)\n      const index = child ? this.nodes.indexOf(child) : null\n      return { start: index, end: index + 1 }\n    }\n\n    // Otherwise, check all of the children...\n    let start = null\n    let end = null\n\n    this.nodes.forEach((child, i) => {\n      if (child.object == 'text') {\n        if (start == null && child.key == startKey) start = i\n        if (end == null && child.key == endKey) end = i + 1\n      } else {\n        if (start == null && child.hasDescendant(startKey)) start = i\n        if (end == null && child.hasDescendant(endKey)) end = i + 1\n      }\n\n      // PERF: exit early if both start and end have been found.\n      return start == null || end == null\n    })\n\n    if (isSelected && start == null) start = 0\n    if (isSelected && end == null) end = this.nodes.size\n    return start == null ? null : { start, end }\n  }\n\n  /**\n   * Get the concatenated text string of all child nodes.\n   *\n   * @return {String}\n   */\n\n  getText() {\n    return this.nodes.reduce((string, node) => {\n      return string + node.text\n    }, '')\n  }\n\n  /**\n   * Get the descendent text node at an `offset`.\n   *\n   * @param {String} offset\n   * @return {Node|Null}\n   */\n\n  getTextAtOffset(offset) {\n    // PERF: Add a few shortcuts for the obvious cases.\n    if (offset == 0) return this.getFirstText()\n    if (offset == this.text.length) return this.getLastText()\n    if (offset < 0 || offset > this.text.length) return null\n\n    let length = 0\n\n    return this.getTexts().find((node, i, nodes) => {\n      length += node.text.length\n      return length > offset\n    })\n  }\n\n  /**\n   * Get the direction of the node's text.\n   *\n   * @return {String}\n   */\n\n  getTextDirection() {\n    const dir = direction(this.text)\n    return dir == 'neutral' ? undefined : dir\n  }\n\n  /**\n   * Recursively get all of the child text nodes in order of appearance.\n   *\n   * @return {List<Node>}\n   */\n\n  getTexts() {\n    const array = this.getTextsAsArray()\n    return new List(array)\n  }\n\n  /**\n   * Recursively get all the leaf text nodes in order of appearance, as array.\n   *\n   * @return {List<Node>}\n   */\n\n  getTextsAsArray() {\n    let array = []\n\n    this.nodes.forEach(node => {\n      if (node.object == 'text') {\n        array.push(node)\n      } else {\n        array = array.concat(node.getTextsAsArray())\n      }\n    })\n\n    return array\n  }\n\n  /**\n   * Get all of the text nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getTextsAtRange(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return List()\n    const { startKey, endKey } = range\n    return new List(this.getTextsBetweenPositionsAsArray(startKey, endKey))\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   * PERF: use key in arguments for cache\n   *\n   * @param {string} startKey\n   * @param {string} endKey\n   * @returns {Array}\n   */\n\n  getTextsBetweenPositionsAsArray(startKey, endKey) {\n    const startText = this.getDescendant(startKey)\n\n    // PERF: the most common case is when the range is in a single text node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startKey == endKey) return [startText]\n\n    const endText = this.getDescendant(endKey)\n    const texts = this.getTextsAsArray()\n    const start = texts.indexOf(startText)\n    const end = texts.indexOf(endText, start)\n    return texts.slice(start, end + 1)\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as an array.\n   *\n   * @param {Range} range\n   * @return {Array}\n   */\n\n  getTextsAtRangeAsArray(range) {\n    range = range.normalize(this)\n    if (range.isUnset) return []\n    const { startKey, endKey } = range\n    return this.getTextsBetweenPositionsAsArray(startKey, endKey)\n  }\n\n  /**\n   * Check if a child node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasChild(key) {\n    return !!this.getChild(key)\n  }\n\n  /**\n   * Check if a node has block node children.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasBlocks(key) {\n    const node = this.assertNode(key)\n    return !!(node.nodes && node.nodes.find(n => n.object === 'block'))\n  }\n\n  /**\n   * Check if a node has inline node children.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasInlines(key) {\n    const node = this.assertNode(key)\n    return !!(\n      node.nodes && node.nodes.find(n => Inline.isInline(n) || Text.isText(n))\n    )\n  }\n\n  /**\n   * Recursively check if a child node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasDescendant(key) {\n    return !!this.getDescendant(key)\n  }\n\n  /**\n   * Recursively check if a node exists by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasNode(key) {\n    return !!this.getNode(key)\n  }\n\n  /**\n   * Check if a node has a void parent by `key`.\n   *\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  hasVoidParent(key) {\n    return !!this.getClosestVoid(key)\n  }\n\n  /**\n   * Insert a `node` at `index`.\n   *\n   * @param {Number} index\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  insertNode(index, node) {\n    const keys = this.getKeysAsArray()\n\n    if (keys.includes(node.key)) {\n      node = node.regenerateKey()\n    }\n\n    if (node.object != 'text') {\n      node = node.mapDescendants(desc => {\n        return keys.includes(desc.key) ? desc.regenerateKey() : desc\n      })\n    }\n\n    const nodes = this.nodes.insert(index, node)\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Check whether the node is in a `range`.\n   *\n   * @param {Range} range\n   * @return {Boolean}\n   */\n\n  isInRange(range) {\n    range = range.normalize(this)\n\n    const node = this\n    const { startKey, endKey, isCollapsed } = range\n\n    // PERF: solve the most common cast where the start or end key are inside\n    // the node, for collapsed selections.\n    if (\n      node.key == startKey ||\n      node.key == endKey ||\n      node.hasDescendant(startKey) ||\n      node.hasDescendant(endKey)\n    ) {\n      return true\n    }\n\n    // PERF: if the selection is collapsed and the previous check didn't return\n    // true, then it must be false.\n    if (isCollapsed) {\n      return false\n    }\n\n    // Otherwise, look through all of the leaf text nodes in the range, to see\n    // if any of them are inside the node.\n    const texts = node.getTextsAtRange(range)\n    let memo = false\n\n    texts.forEach(text => {\n      if (node.hasDescendant(text.key)) memo = true\n      return memo\n    })\n\n    return memo\n  }\n\n  /**\n   * Check whether the node is a leaf block.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafBlock() {\n    return this.object == 'block' && this.nodes.every(n => n.object != 'block')\n  }\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafInline() {\n    return (\n      this.object == 'inline' && this.nodes.every(n => n.object != 'inline')\n    )\n  }\n\n  /**\n   * Merge a children node `first` with another children node `second`.\n   * `first` and `second` will be concatenated in that order.\n   * `first` and `second` must be two Nodes or two Text.\n   *\n   * @param {Node} first\n   * @param {Node} second\n   * @return {Node}\n   */\n\n  mergeNode(withIndex, index) {\n    let node = this\n    let one = node.nodes.get(withIndex)\n    const two = node.nodes.get(index)\n\n    if (one.object != two.object) {\n      throw new Error(\n        `Tried to merge two nodes of different objects: \"${one.object}\" and \"${\n          two.object\n        }\".`\n      )\n    }\n\n    // If the nodes are text nodes, concatenate their leaves together\n    if (one.object == 'text') {\n      one = one.mergeText(two)\n    } else {\n      // Otherwise, concatenate their child nodes together.\n      const nodes = one.nodes.concat(two.nodes)\n      one = one.set('nodes', nodes)\n    }\n\n    node = node.removeNode(index)\n    node = node.removeNode(withIndex)\n    node = node.insertNode(withIndex, one)\n    return node\n  }\n\n  /**\n   * Map all child nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapChildren(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, i) => {\n      const ret = iterator(node, i, this.nodes)\n      if (ret != node) nodes = nodes.set(ret.key, ret)\n    })\n\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Map all descendant nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} iterator\n   * @return {Node}\n   */\n\n  mapDescendants(iterator) {\n    let { nodes } = this\n\n    nodes.forEach((node, index) => {\n      let ret = node\n      if (ret.object != 'text') ret = ret.mapDescendants(iterator)\n      ret = iterator(ret, index, this.nodes)\n      if (ret == node) return\n\n      nodes = nodes.set(index, ret)\n    })\n\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Node}\n   */\n\n  regenerateKey() {\n    const key = generateKey()\n    return this.set('key', key)\n  }\n\n  /**\n   * Remove a `node` from the children node map.\n   *\n   * @param {String} key\n   * @return {Node}\n   */\n\n  removeDescendant(key) {\n    key = assertKey(key)\n\n    let node = this\n    let parent = node.getParent(key)\n    if (!parent)\n      throw new Error(`Could not find a descendant node with key \"${key}\".`)\n\n    const index = parent.nodes.findIndex(n => n.key === key)\n    const nodes = parent.nodes.delete(index)\n\n    parent = parent.set('nodes', nodes)\n    node = node.updateNode(parent)\n    return node\n  }\n\n  /**\n   * Remove a node at `index`.\n   *\n   * @param {Number} index\n   * @return {Node}\n   */\n\n  removeNode(index) {\n    const nodes = this.nodes.delete(index)\n    return this.set('nodes', nodes)\n  }\n\n  /**\n   * Split a child node by `index` at `position`.\n   *\n   * @param {Number} index\n   * @param {Number} position\n   * @return {Node}\n   */\n\n  splitNode(index, position) {\n    let node = this\n    const child = node.nodes.get(index)\n    let one\n    let two\n\n    // If the child is a text node, the `position` refers to the text offset at\n    // which to split it.\n    if (child.object == 'text') {\n      ;[one, two] = child.splitText(position)\n    } else {\n      // Otherwise, if the child is not a text node, the `position` refers to the\n      // index at which to split its children.\n      const befores = child.nodes.take(position)\n      const afters = child.nodes.skip(position)\n      one = child.set('nodes', befores)\n      two = child.set('nodes', afters).regenerateKey()\n    }\n\n    // Remove the old node and insert the newly split children.\n    node = node.removeNode(index)\n    node = node.insertNode(index, two)\n    node = node.insertNode(index, one)\n    return node\n  }\n\n  /**\n   * Set a new value for a child node by `key`.\n   *\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  updateNode(node) {\n    if (node.key == this.key) {\n      return node\n    }\n\n    let child = this.assertDescendant(node.key)\n    const ancestors = this.getAncestors(node.key)\n\n    ancestors.reverse().forEach(parent => {\n      let { nodes } = parent\n      const index = nodes.indexOf(child)\n      child = parent\n      nodes = nodes.set(index, node)\n      parent = parent.set('nodes', nodes)\n      node = parent\n    })\n\n    return node\n  }\n\n  /**\n   * Validate the node against a `schema`.\n   *\n   * @param {Schema} schema\n   * @return {Function|Null}\n   */\n\n  validate(schema) {\n    return schema.validateNode(this)\n  }\n\n  /**\n   * Get the first invalid descendant\n   *\n   * @param {Schema} schema\n   * @return {Node|Text|Null}\n   */\n\n  getFirstInvalidDescendant(schema) {\n    let result = null\n\n    this.nodes.find(n => {\n      result = n.validate(schema) ? n : n.getFirstInvalidDescendant(schema)\n      return result\n    })\n    return result\n  }\n}\n\n/**\n * Assert a key `arg`.\n *\n * @param {String} arg\n * @return {String}\n */\n\nfunction assertKey(arg) {\n  if (typeof arg == 'string') return arg\n  throw new Error(\n    `Invalid \\`key\\` argument! It must be a key string, but you passed: ${arg}`\n  )\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Node.prototype, [\n  'areDescendantsSorted',\n  'getAncestors',\n  'getBlocksAsArray',\n  'getBlocksAtRangeAsArray',\n  'getBlocksByTypeAsArray',\n  'getChild',\n  'getClosestBlock',\n  'getClosestInline',\n  'getClosestVoid',\n  'getCommonAncestor',\n  'getDecorations',\n  'getDepth',\n  'getDescendant',\n  'getDescendantAtPath',\n  'getFirstText',\n  'getFragmentAtRange',\n  'getFurthestBlock',\n  'getFurthestInline',\n  'getFurthestAncestor',\n  'getFurthestOnlyChildAncestor',\n  'getInlinesAsArray',\n  'getInlinesAtRangeAsArray',\n  'getInlinesByTypeAsArray',\n  'getMarksAsArray',\n  'getMarksAtPosition',\n  'getOrderedMarksBetweenPositions',\n  'getInsertMarksAtRange',\n  'getKeysAsArray',\n  'getLastText',\n  'getMarksByTypeAsArray',\n  'getNextBlock',\n  'getNextSibling',\n  'getNextText',\n  'getNode',\n  'getNodeAtPath',\n  'getOffset',\n  'getOffsetAtRange',\n  'getParent',\n  'getPath',\n  'getPlaceholder',\n  'getPreviousBlock',\n  'getPreviousSibling',\n  'getPreviousText',\n  'getText',\n  'getTextAtOffset',\n  'getTextDirection',\n  'getTextsAsArray',\n  'getTextsBetweenPositionsAsArray',\n  'isLeafBlock',\n  'isLeafInline',\n  'validate',\n  'getFirstInvalidDescendant',\n])\n\n/**\n * Mix in `Node` methods.\n */\n\nObject.getOwnPropertyNames(Node.prototype).forEach(method => {\n  if (method == 'constructor') return\n  Block.prototype[method] = Node.prototype[method]\n  Inline.prototype[method] = Node.prototype[method]\n  Document.prototype[method] = Node.prototype[method]\n})\n\nBlock.createChildren = Node.createList\nInline.createChildren = Node.createList\nDocument.createChildren = Node.createList\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Node\n","import { reverse } from 'esrever'\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nconst SPACE = /\\s/\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nconst CHAMELEON = /['\\u2018\\u2019]/\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharLength(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n    if (isWord(next, rest)) return true\n  }\n\n  if (PUNCTUATION.test(char)) return false\n  return true\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1\n}\n\n/**\n * Get the offset to the end of the first character in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getCharOffset(text) {\n  const char = text.charAt(0)\n  return getCharLength(char)\n}\n\n/**\n * Get the offset to the end of the character before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the character after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  text = text.slice(offset)\n  return getCharOffset(text)\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharLength(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWord(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  getCharOffsetForward,\n  getCharOffsetBackward,\n  getWordOffsetBackward,\n  getWordOffsetForward,\n}\n","import { List } from 'immutable'\nimport logger from '@gitbook/slate-dev-logger'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport String from '../utils/string'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset, endKey, endOffset } = range\n  const texts = document.getTextsAtRange(range)\n\n  texts.forEach(node => {\n    const { key } = node\n    let index = 0\n    let length = node.text.length\n\n    if (key == startKey) index = startOffset\n    if (key == endKey) length = endOffset\n    if (key == startKey && key == endKey) length = endOffset - startOffset\n\n    change.addMarkByKey(key, index, length, mark, { normalize })\n  })\n}\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Array<Mixed>} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarksAtRange = (change, range, marks, options = {}) => {\n  marks.forEach(mark => change.addMarkAtRange(range, mark, options))\n}\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteAtRange = (change, range, options = {}) => {\n  if (range.isCollapsed) return\n\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  change.snapshotSelection()\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  let { startKey, startOffset, endKey, endOffset } = range\n  let { document } = value\n  let isStartVoid = document.hasVoidParent(startKey)\n  let isEndVoid = document.hasVoidParent(endKey)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    startOffset == 0 &&\n    endOffset == 0 &&\n    isStartVoid == false &&\n    startKey == startBlock.getFirstText().key &&\n    endKey == endBlock.getFirstText().key\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    const prevText = document.getPreviousText(endKey)\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey)\n  }\n\n  // If the start node is inside a void node, remove the void node and update\n  // the starting point to be right after it, continuously until the start point\n  // is not a void, or until the entire range is handled.\n  while (isStartVoid) {\n    const startVoid = document.getClosestVoid(startKey)\n    const nextText = document.getNextText(startKey)\n    change.removeNodeByKey(startVoid.key, { normalize: false })\n\n    // If the start and end keys are the same, we're done.\n    if (startKey == endKey) return\n\n    // If there is no next text node, we're done.\n    if (!nextText) return\n\n    // Continue...\n    document = change.value.document\n    startKey = nextText.key\n    startOffset = 0\n    isStartVoid = document.hasVoidParent(startKey)\n  }\n\n  // If the end node is inside a void node, do the same thing but backwards. But\n  // we don't need any aborting checks because if we've gotten this far there\n  // must be a non-void node that will exit the loop.\n  while (isEndVoid) {\n    const endVoid = document.getClosestVoid(endKey)\n    const prevText = document.getPreviousText(endKey)\n    change.removeNodeByKey(endVoid.key, { normalize: false })\n\n    // Continue...\n    document = change.value.document\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey)\n  }\n\n  // If the start and end key are the same, and it was a hanging selection, we\n  // can just remove the entire block.\n  if (startKey == endKey && isHanging) {\n    change.removeNodeByKey(startBlock.key, { normalize })\n    return\n  } else if (startKey == endKey) {\n    // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n    // simply remove the text in the range.\n    const index = startOffset\n    const length = endOffset - startOffset\n    change.removeTextByKey(startKey, index, length, { normalize })\n    return\n  } else {\n    // Otherwise, we need to recursively remove text and nodes inside the start\n    // block after the start offset and inside the end block before the end\n    // offset. Then remove any blocks that are in between the start and end\n    // blocks. Then finally merge the start and end nodes.\n    startBlock = document.getClosestBlock(startKey)\n    endBlock = document.getClosestBlock(endKey)\n    const startText = document.getNode(startKey)\n    const endText = document.getNode(endKey)\n    const startLength = startText.text.length - startOffset\n    const endLength = endOffset\n\n    const ancestor = document.getCommonAncestor(startKey, endKey)\n    const startChild = ancestor.getFurthestAncestor(startKey)\n    const endChild = ancestor.getFurthestAncestor(endKey)\n\n    const startParent = document.getParent(startBlock.key)\n    const startParentIndex = startParent.nodes.indexOf(startBlock)\n    const endParentIndex = startParent.nodes.indexOf(endBlock)\n\n    let child\n\n    // Iterate through all of the nodes in the tree after the start text node\n    // but inside the end child, and remove them.\n    child = startText\n\n    while (child.key != startChild.key) {\n      const parent = document.getParent(child.key)\n      const index = parent.nodes.indexOf(child)\n      const afters = parent.nodes.slice(index + 1)\n\n      afters.reverse().forEach(node => {\n        change.removeNodeByKey(node.key, { normalize: false })\n      })\n\n      child = parent\n    }\n\n    // Remove all of the middle children.\n    const startChildIndex = ancestor.nodes.indexOf(startChild)\n    const endChildIndex = ancestor.nodes.indexOf(endChild)\n    const middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex)\n\n    middles.reverse().forEach(node => {\n      change.removeNodeByKey(node.key, { normalize: false })\n    })\n\n    // Remove the nodes before the end text node in the tree.\n    child = endText\n\n    while (child.key != endChild.key) {\n      const parent = document.getParent(child.key)\n      const index = parent.nodes.indexOf(child)\n      const befores = parent.nodes.slice(0, index)\n\n      befores.reverse().forEach(node => {\n        change.removeNodeByKey(node.key, { normalize: false })\n      })\n\n      child = parent\n    }\n\n    // Remove any overlapping text content from the leaf text nodes.\n    if (startLength != 0) {\n      change.removeTextByKey(startKey, startOffset, startLength, {\n        normalize: false,\n      })\n    }\n\n    if (endLength != 0) {\n      change.removeTextByKey(endKey, 0, endOffset, { normalize: false })\n    }\n\n    // If the start and end blocks aren't the same, move and merge the end block\n    // into the start block.\n    if (startBlock.key != endBlock.key) {\n      document = change.value.document\n      const lonely = document.getFurthestOnlyChildAncestor(endBlock.key)\n\n      // Move the end block to be right after the start block.\n      if (endParentIndex != startParentIndex + 1) {\n        change.moveNodeByKey(\n          endBlock.key,\n          startParent.key,\n          startParentIndex + 1,\n          { normalize: false }\n        )\n      }\n\n      // If the selection is hanging, just remove the start block, otherwise\n      // merge the end block into it.\n      if (isHanging) {\n        change.removeNodeByKey(startBlock.key, { normalize: false })\n      } else {\n        change.mergeNodeByKey(endBlock.key, { normalize: false })\n      }\n\n      // If nested empty blocks are left over above the end block, remove them.\n      if (lonely) {\n        change.removeNodeByKey(lonely.key, { normalize: false })\n      }\n    }\n\n    // If we should normalize, do it now after everything.\n    if (normalize) {\n      change.normalizeNodeByKey(ancestor.key)\n    }\n  }\n}\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteCharBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getCharOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n, options)\n}\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteLineBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  change.deleteBackwardAtRange(range, o, options)\n}\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteWordBackwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getWordOffsetBackward(text, o)\n  change.deleteBackwardAtRange(range, n, options)\n}\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteBackwardAtRange = (change, range, n = 1, options = {}) => {\n  if (n === 0) return\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, focusOffset } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  const voidParent = document.getClosestVoid(startKey)\n\n  // If there is a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize })\n    return\n  }\n\n  const block = document.getClosestBlock(startKey)\n\n  // If the closest is not void, but empty, remove it\n  if (block && block.isEmpty && document.nodes.size !== 1) {\n    change.removeNodeByKey(block.key, { normalize })\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtStartOf(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(startKey)\n\n  if (range.isAtStartOf(text)) {\n    const prev = document.getPreviousText(text.key)\n    const prevBlock = document.getClosestBlock(prev.key)\n    const prevVoid = document.getClosestVoid(prev.key)\n\n    // If the previous text node has a void parent, remove it.\n    if (prevVoid) {\n      change.removeNodeByKey(prevVoid.key, { normalize })\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && prevBlock != block) {\n      range = range.merge({\n        anchorKey: prev.key,\n        anchorOffset: prev.text.length,\n      })\n\n      change.deleteAtRange(range, { normalize })\n      return\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n < focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset - n,\n      isBackward: true,\n    })\n\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  let node = text\n  let offset = 0\n  let traversed = focusOffset\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = next - n\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n    isBackward: true,\n  })\n\n  change.deleteAtRange(range, { normalize })\n}\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteCharForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getCharOffsetForward(text, o)\n  change.deleteForwardAtRange(range, n, options)\n}\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteLineForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  change.deleteForwardAtRange(range, startBlock.text.length - o, options)\n}\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteWordForwardAtRange = (change, range, options) => {\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const offset = startBlock.getOffset(startKey)\n  const o = offset + startOffset\n  const { text } = startBlock\n  const n = String.getWordOffsetForward(text, o)\n  change.deleteForwardAtRange(range, n, options)\n}\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} n (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.deleteForwardAtRange = (change, range, n = 1, options = {}) => {\n  if (n === 0) return\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const { startKey, focusOffset } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  const voidParent = document.getClosestVoid(startKey)\n\n  // If the node has a void parent, delete it.\n  if (voidParent) {\n    change.removeNodeByKey(voidParent.key, { normalize })\n    return\n  }\n\n  const block = document.getClosestBlock(startKey)\n\n  // If the closest is not void, but empty, remove it\n  if (block && block.isEmpty && document.nodes.size !== 1) {\n    const nextBlock = document.getNextBlock(block.key)\n    change.removeNodeByKey(block.key, { normalize })\n\n    if (nextBlock && nextBlock.key) {\n      change.moveToStartOf(nextBlock)\n    }\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (range.isAtEndOf(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(startKey)\n\n  if (range.isAtEndOf(text)) {\n    const next = document.getNextText(text.key)\n    const nextBlock = document.getClosestBlock(next.key)\n    const nextVoid = document.getClosestVoid(next.key)\n\n    // If the next text node has a void parent, remove it.\n    if (nextVoid) {\n      change.removeNodeByKey(nextVoid.key, { normalize })\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n == 1 && nextBlock != block) {\n      range = range.merge({\n        focusKey: next.key,\n        focusOffset: 0,\n      })\n\n      change.deleteAtRange(range, { normalize })\n      return\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focusOffset) {\n    range = range.merge({\n      focusOffset: focusOffset + n,\n    })\n\n    change.deleteAtRange(range, { normalize })\n    return\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  let node = text\n  let offset = focusOffset\n  let traversed = text.text.length - focusOffset\n\n  while (n > traversed) {\n    node = document.getNextText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = n - traversed\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  // If the focus node is inside a void, go up until right before it.\n  if (document.hasVoidParent(node.key)) {\n    const parent = document.getClosestVoid(node.key)\n    node = document.getPreviousText(parent.key)\n    offset = node.text.length\n  }\n\n  range = range.merge({\n    focusKey: node.key,\n    focusOffset: offset,\n  })\n\n  change.deleteAtRange(range, { normalize })\n}\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|String|Object} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertBlockAtRange = (change, range, block, options = {}) => {\n  block = Block.create(block)\n  const normalize = change.getFlag('normalize', options)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range)\n    range = range.collapseToStart()\n  }\n\n  const { value } = change\n  const { document } = value\n  let { startKey, startOffset } = range\n  const startBlock = document.getClosestBlock(startKey)\n  const startInline = document.getClosestInline(startKey)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n\n  if (startBlock.isVoid) {\n    const extra = range.isAtEndOf(startBlock) ? 1 : 0\n    change.insertNodeByKey(parent.key, index + extra, block, { normalize })\n  } else if (startBlock.isEmpty) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  } else if (range.isAtStartOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index, block, { normalize })\n  } else if (range.isAtEndOf(startBlock)) {\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  } else {\n    if (startInline && startInline.isVoid) {\n      const atEnd = range.isAtEndOf(startInline)\n      const siblingText = atEnd\n        ? document.getNextText(startKey)\n        : document.getPreviousText(startKey)\n\n      const splitRange = atEnd\n        ? range.moveToStartOf(siblingText)\n        : range.moveToEndOf(siblingText)\n\n      startKey = splitRange.startKey\n      startOffset = splitRange.startOffset\n    }\n\n    change.splitDescendantsByKey(startBlock.key, startKey, startOffset, {\n      normalize: false,\n    })\n\n    change.insertNodeByKey(parent.key, index + 1, block, { normalize })\n  }\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Document} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertFragmentAtRange = (change, range, fragment, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  // If the range is expanded, delete it first.\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n\n    if (change.value.document.getDescendant(range.startKey)) {\n      range = range.collapseToStart()\n    } else {\n      range = range.collapseTo(range.endKey, 0)\n    }\n  }\n\n  // If the fragment is empty, there's nothing to do after deleting.\n  if (!fragment.nodes.size) return\n\n  // Regenerate the keys for all of the fragments nodes, so that they're\n  // guaranteed not to collide with the existing keys in the document. Otherwise\n  // they will be rengerated automatically and we won't have an easy way to\n  // reference them.\n  fragment = fragment.mapDescendants(child => child.regenerateKey())\n\n  // Calculate a few things...\n  const { startKey, startOffset } = range\n  const { value } = change\n  let { document } = value\n  let startText = document.getDescendant(startKey)\n  let startBlock = document.getClosestBlock(startText.key)\n  let startChild = startBlock.getFurthestAncestor(startText.key)\n  const isAtStart = range.isAtStartOf(startBlock)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n  const blocks = fragment.getBlocks()\n  const firstChild = fragment.nodes.first()\n  const lastChild = fragment.nodes.last()\n  const firstBlock = blocks.first()\n  const lastBlock = blocks.last()\n\n  // If the fragment only contains a void block, use `insertBlock` instead.\n  if (firstBlock == lastBlock && firstBlock.isVoid) {\n    change.insertBlockAtRange(range, firstBlock, options)\n    return\n  }\n\n  // If the fragment starts or ends with single nested block, (e.g., table),\n  // do not merge this fragment with existing blocks.\n  if (fragment.hasBlocks(firstChild.key) || fragment.hasBlocks(lastChild.key)) {\n    fragment.nodes.reverse().forEach(node => {\n      change.insertBlockAtRange(range, node, options)\n    })\n    return\n  }\n\n  // If the first and last block aren't the same, we need to insert all of the\n  // nodes after the fragment's first block at the index.\n  if (firstBlock != lastBlock) {\n    const lonelyParent = fragment.getFurthest(\n      firstBlock.key,\n      p => p.nodes.size == 1\n    )\n    const lonelyChild = lonelyParent || firstBlock\n    const startIndex = parent.nodes.indexOf(startBlock)\n    fragment = fragment.removeDescendant(lonelyChild.key)\n\n    fragment.nodes.forEach((node, i) => {\n      const newIndex = startIndex + i + 1\n      change.insertNodeByKey(parent.key, newIndex, node, { normalize: false })\n    })\n  }\n\n  // Check if we need to split the node.\n  if (startOffset != 0) {\n    change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n      normalize: false,\n    })\n  }\n\n  // Update our variables with the new value.\n  document = change.value.document\n  startText = document.getDescendant(startKey)\n  startBlock = document.getClosestBlock(startKey)\n  startChild = startBlock.getFurthestAncestor(startText.key)\n\n  // If the first and last block aren't the same, we need to move any of the\n  // starting block's children after the split into the last block of the\n  // fragment, which has already been inserted.\n  if (firstBlock != lastBlock) {\n    const nextChild = isAtStart\n      ? startChild\n      : startBlock.getNextSibling(startChild.key)\n    const nextNodes = nextChild\n      ? startBlock.nodes.skipUntil(n => n.key == nextChild.key)\n      : List()\n    const lastIndex = lastBlock.nodes.size\n\n    nextNodes.forEach((node, i) => {\n      const newIndex = lastIndex + i\n\n      change.moveNodeByKey(node.key, lastBlock.key, newIndex, {\n        normalize: false,\n      })\n    })\n  }\n\n  // If the starting block is empty, we replace it entirely with the first block\n  // of the fragment, since this leads to a more expected behavior for the user.\n  if (startBlock.isEmpty) {\n    change.removeNodeByKey(startBlock.key, { normalize: false })\n    change.insertNodeByKey(parent.key, index, firstBlock, { normalize: false })\n  } else {\n    // Otherwise, we maintain the starting block, and insert all of the first\n    // block's inline nodes into it at the split point.\n    const inlineChild = startBlock.getFurthestAncestor(startText.key)\n    const inlineIndex = startBlock.nodes.indexOf(inlineChild)\n\n    firstBlock.nodes.forEach((inline, i) => {\n      const o = startOffset == 0 ? 0 : 1\n      const newIndex = inlineIndex + i + o\n\n      change.insertNodeByKey(startBlock.key, newIndex, inline, {\n        normalize: false,\n      })\n    })\n  }\n\n  // Normalize if requested.\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|String|Object} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertInlineAtRange = (change, range, inline, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  inline = Inline.create(inline)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n    range = range.collapseToStart()\n  }\n\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  const parent = document.getParent(startKey)\n  const startText = document.assertDescendant(startKey)\n  const index = parent.nodes.indexOf(startText)\n\n  if (parent.isVoid) return\n\n  change.splitNodeByKey(startKey, startOffset, { normalize: false })\n  change.insertNodeByKey(parent.key, index + 1, inline, { normalize: false })\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertTextAtRange = (change, range, text, marks, options = {}) => {\n  let { normalize } = options\n  const { value } = change\n  const { document } = value\n  const { startKey, startOffset } = range\n  let key = startKey\n  let offset = startOffset\n  const parent = document.getParent(startKey)\n\n  if (parent.isVoid) return\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize: false })\n\n    // Update range start after delete\n    if (change.value.startKey !== key) {\n      key = change.value.startKey\n      offset = change.value.startOffset\n    }\n  }\n\n  // PERF: Unless specified, don't normalize if only inserting text.\n  if (normalize === undefined) {\n    normalize = range.isExpanded && marks && marks.size !== 0\n  }\n\n  change.insertTextByKey(key, offset, text, marks, { normalize: false })\n\n  if (normalize) {\n    // normalize in the narrowest existing block that originally contains startKey and endKey\n    const commonAncestor = document.getCommonAncestor(startKey, range.endKey)\n    const ancestors = document\n      .getAncestors(commonAncestor.key)\n      .push(commonAncestor)\n    const normalizeAncestor = ancestors.findLast(n =>\n      change.value.document.getDescendant(n.key)\n    )\n    // it is possible that normalizeAncestor doesn't return any node\n    // on that case fallback to startKey to be normalized\n    const normalizeKey = normalizeAncestor ? normalizeAncestor.key : startKey\n    change.normalizeNodeByKey(normalizeKey)\n  }\n}\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const { startKey, startOffset, endKey, endOffset } = range\n\n  texts.forEach(node => {\n    const { key } = node\n    let index = 0\n    let length = node.text.length\n\n    if (key == startKey) index = startOffset\n    if (key == endKey) length = endOffset\n    if (key == startKey && key == endKey) length = endOffset - startOffset\n\n    change.removeMarkByKey(key, index, length, mark, { normalize })\n  })\n}\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setBlocksAtRange = (change, range, properties, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const blocks = document.getBlocksAtRange(range)\n\n  const { startKey, startOffset, endKey, endOffset, isCollapsed } = range\n  const isStartVoid = document.hasVoidParent(startKey)\n  const startBlock = document.getClosestBlock(startKey)\n  const endBlock = document.getClosestBlock(endKey)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    isCollapsed == false &&\n    startOffset == 0 &&\n    endOffset == 0 &&\n    isStartVoid == false &&\n    startKey == startBlock.getFirstText().key &&\n    endKey == endBlock.getFirstText().key\n\n  // If it's a hanging selection, ignore the last block.\n  const sets = isHanging ? blocks.slice(0, -1) : blocks\n\n  sets.forEach(block => {\n    change.setNodeByKey(block.key, properties, { normalize })\n  })\n}\n\nChanges.setBlockAtRange = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setBlockAtRange` method of Slate changes has been renamed to `setBlocksAtRange`.'\n  )\n\n  Changes.setBlocksAtRange(...args)\n}\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setInlinesAtRange = (change, range, properties, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const inlines = document.getInlinesAtRange(range)\n\n  inlines.forEach(inline => {\n    change.setNodeByKey(inline.key, properties, { normalize })\n  })\n}\n\nChanges.setInlineAtRange = (...args) => {\n  logger.deprecate(\n    'slate@0.33.0',\n    'The `setInlineAtRange` method of Slate changes has been renamed to `setInlinesAtRange`.'\n  )\n\n  Changes.setInlinesAtRange(...args)\n}\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitBlockAtRange = (change, range, height = 1, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  const { startKey, startOffset, endOffset, endKey } = range\n  const { value } = change\n  const { document } = value\n  let node = document.assertDescendant(startKey)\n  let parent = document.getClosestBlock(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'block' && h < height) {\n    node = parent\n    parent = document.getClosestBlock(parent.key)\n    h++\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, {\n    normalize: normalize && range.isCollapsed,\n  })\n\n  if (range.isExpanded) {\n    if (range.isBackward) range = range.flip()\n    const nextBlock = change.value.document.getNextBlock(node.key)\n    range = range.moveAnchorToStartOf(nextBlock)\n\n    if (startKey === endKey) {\n      range = range.moveFocusTo(range.anchorKey, endOffset - startOffset)\n    }\n\n    change.deleteAtRange(range, { normalize })\n  }\n}\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Number} height (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitInlineAtRange = (\n  change,\n  range,\n  height = Infinity,\n  options = {}\n) => {\n  const normalize = change.getFlag('normalize', options)\n\n  if (range.isExpanded) {\n    change.deleteAtRange(range, { normalize })\n    range = range.collapseToStart()\n  }\n\n  const { startKey, startOffset } = range\n  const { value } = change\n  const { document } = value\n  let node = document.assertDescendant(startKey)\n  let parent = document.getClosestInline(node.key)\n  let h = 0\n\n  while (parent && parent.object == 'inline' && h < height) {\n    node = parent\n    parent = document.getClosestInline(parent.key)\n    h++\n  }\n\n  change.splitDescendantsByKey(node.key, startKey, startOffset, { normalize })\n}\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.toggleMarkAtRange = (change, range, mark, options = {}) => {\n  if (range.isCollapsed) return\n\n  mark = Mark.create(mark)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const marks = document.getActiveMarksAtRange(range)\n  const exists = marks.some(m => m.equals(mark))\n\n  if (exists) {\n    change.removeMarkAtRange(range, mark, { normalize })\n  } else {\n    change.addMarkAtRange(range, mark, { normalize })\n  }\n}\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapBlockAtRange = (change, range, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n\n  const normalize = change.getFlag('normalize', options)\n  const blocks = change.value.document.getBlocksAtRange(range)\n  const wrappers = blocks\n    .map(block => {\n      return change.value.document.getClosest(block.key, parent => {\n        if (parent.object != 'block') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.isVoid != null && parent.isVoid != properties.isVoid)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  wrappers.forEach(block => {\n    const first = block.nodes.first()\n    const last = block.nodes.last()\n    const parent = change.value.document.getParent(block.key)\n    const index = parent.nodes.indexOf(block)\n\n    const children = block.nodes.filter(child => {\n      return blocks.some(b => child == b || child.hasDescendant(b.key))\n    })\n\n    const firstMatch = children.first()\n    const lastMatch = children.last()\n\n    if (first == firstMatch && last == lastMatch) {\n      block.nodes.forEach((child, i) => {\n        change.moveNodeByKey(child.key, parent.key, index + i, {\n          normalize: false,\n        })\n      })\n\n      change.removeNodeByKey(block.key, { normalize: false })\n    } else if (last == lastMatch) {\n      block.nodes.skipUntil(n => n == firstMatch).forEach((child, i) => {\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false,\n        })\n      })\n    } else if (first == firstMatch) {\n      block.nodes\n        .takeUntil(n => n == lastMatch)\n        .push(lastMatch)\n        .forEach((child, i) => {\n          change.moveNodeByKey(child.key, parent.key, index + i, {\n            normalize: false,\n          })\n        })\n    } else {\n      const firstText = firstMatch.getFirstText()\n\n      change.splitDescendantsByKey(block.key, firstText.key, 0, {\n        normalize: false,\n      })\n\n      children.forEach((child, i) => {\n        if (i == 0) {\n          const extra = child\n          child = change.value.document.getNextBlock(child.key)\n          change.removeNodeByKey(extra.key, { normalize: false })\n        }\n\n        change.moveNodeByKey(child.key, parent.key, index + 1 + i, {\n          normalize: false,\n        })\n      })\n    }\n  })\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument()\n  }\n}\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String|Object} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapInlineAtRange = (change, range, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const inlines = texts\n    .map(text => {\n      return document.getClosest(text.key, parent => {\n        if (parent.object != 'inline') return false\n        if (properties.type != null && parent.type != properties.type)\n          return false\n        if (properties.isVoid != null && parent.isVoid != properties.isVoid)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  inlines.forEach(inline => {\n    const parent = change.value.document.getParent(inline.key)\n    const index = parent.nodes.indexOf(inline)\n\n    inline.nodes.forEach((child, i) => {\n      change.moveNodeByKey(child.key, parent.key, index + i, {\n        normalize: false,\n      })\n    })\n  })\n\n  // TODO: optmize to only normalize the right block\n  if (normalize) {\n    change.normalizeDocument()\n  }\n}\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Block|Object|String} block\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapBlockAtRange = (change, range, block, options = {}) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n\n  const blocks = document.getBlocksAtRange(range)\n  const firstblock = blocks.first()\n  const lastblock = blocks.last()\n  let parent, siblings, index\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key)\n    siblings = blocks\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, p1 => {\n      return !!document.getClosest(lastblock.key, p2 => p1 == p2)\n    })\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    const indexes = parent.nodes.reduce((ind, node, i) => {\n      if (node == firstblock || node.hasDescendant(firstblock.key)) ind[0] = i\n      if (node == lastblock || node.hasDescendant(lastblock.key)) ind[1] = i\n      return ind\n    }, [])\n\n    index = indexes[0]\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1)\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first())\n  }\n\n  // Inject the new block node into the parent.\n  change.insertNodeByKey(parent.key, index, block, { normalize: false })\n\n  // Move the sibling nodes into the new block node.\n  siblings.forEach((node, i) => {\n    change.moveNodeByKey(node.key, block.key, i, { normalize: false })\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {Inline|Object|String} inline\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapInlineAtRange = (change, range, inline, options = {}) => {\n  const { value } = change\n  let { document } = value\n  const normalize = change.getFlag('normalize', options)\n  const { startKey, startOffset, endKey, endOffset } = range\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    const inlineParent = document.getClosestInline(startKey)\n\n    if (!inlineParent.isVoid) {\n      return\n    }\n\n    return change.wrapInlineByKey(inlineParent.key, inline, options)\n  }\n\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const blocks = document.getBlocksAtRange(range)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n  const startInline = document.getClosestInline(startKey)\n  const endInline = document.getClosestInline(endKey)\n  let startChild = startBlock.getFurthestAncestor(startKey)\n  let endChild = endBlock.getFurthestAncestor(endKey)\n\n  if (!startInline || startInline != endInline) {\n    change.splitDescendantsByKey(endChild.key, endKey, endOffset, {\n      normalize: false,\n    })\n\n    change.splitDescendantsByKey(startChild.key, startKey, startOffset, {\n      normalize: false,\n    })\n  }\n\n  document = change.value.document\n  startBlock = document.getDescendant(startBlock.key)\n  endBlock = document.getDescendant(endBlock.key)\n  startChild = startBlock.getFurthestAncestor(startKey)\n  endChild = endBlock.getFurthestAncestor(endKey)\n  const startIndex = startBlock.nodes.indexOf(startChild)\n  const endIndex = endBlock.nodes.indexOf(endChild)\n\n  if (startInline && startInline == endInline) {\n    const text = startBlock\n      .getTextsAtRange(range)\n      .get(0)\n      .splitText(startOffset)[1]\n      .splitText(endOffset - startOffset)[0]\n    inline = inline.set('nodes', List([text]))\n    Changes.insertInlineAtRange(change, range, inline, { normalize: false })\n    const inlinekey = inline.getFirstText().key\n    const rng = {\n      anchorKey: inlinekey,\n      focusKey: inlinekey,\n      anchorOffset: 0,\n      focusOffset: endOffset - startOffset,\n      isFocused: true,\n    }\n    change.select(rng)\n  } else if (startBlock == endBlock) {\n    document = change.value.document\n    startBlock = document.getClosestBlock(startKey)\n    startChild = startBlock.getFurthestAncestor(startKey)\n\n    const startInner = document.getNextSibling(startChild.key)\n    const startInnerIndex = startBlock.nodes.indexOf(startInner)\n    const endInner =\n      startKey == endKey ? startInner : startBlock.getFurthestAncestor(endKey)\n    const inlines = startBlock.nodes\n      .skipUntil(n => n == startInner)\n      .takeUntil(n => n == endInner)\n      .push(endInner)\n\n    const node = inline.regenerateKey()\n\n    change.insertNodeByKey(startBlock.key, startInnerIndex, node, {\n      normalize: false,\n    })\n\n    inlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, node.key, i, { normalize: false })\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key)\n    }\n  } else {\n    const startInlines = startBlock.nodes.slice(startIndex + 1)\n    const endInlines = endBlock.nodes.slice(0, endIndex + 1)\n    const startNode = inline.regenerateKey()\n    const endNode = inline.regenerateKey()\n\n    change.insertNodeByKey(startBlock.key, startIndex + 1, startNode, {\n      normalize: false,\n    })\n\n    change.insertNodeByKey(endBlock.key, endIndex, endNode, {\n      normalize: false,\n    })\n\n    startInlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, startNode.key, i, { normalize: false })\n    })\n\n    endInlines.forEach((child, i) => {\n      change.moveNodeByKey(child.key, endNode.key, i, { normalize: false })\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(startBlock.key).normalizeNodeByKey(endBlock.key)\n    }\n\n    blocks.slice(1, -1).forEach(block => {\n      const node = inline.regenerateKey()\n      change.insertNodeByKey(block.key, 0, node, { normalize: false })\n\n      block.nodes.forEach((child, i) => {\n        change.moveNodeByKey(child.key, node.key, i, { normalize: false })\n      })\n\n      if (normalize) {\n        change.normalizeNodeByKey(block.key)\n      }\n    })\n  }\n}\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Change} change\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapTextAtRange = (\n  change,\n  range,\n  prefix,\n  suffix = prefix,\n  options = {}\n) => {\n  const normalize = change.getFlag('normalize', options)\n  const { startKey, endKey } = range\n  const start = range.collapseToStart()\n  let end = range.collapseToEnd()\n\n  if (startKey == endKey) {\n    end = end.move(prefix.length)\n  }\n\n  change.insertTextAtRange(start, prefix, [], { normalize })\n  change.insertTextAtRange(end, suffix, [], { normalize })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport Range from '../models/range'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Add mark to text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.addMarkByKey = (change, key, offset, length, mark, options = {}) => {\n  mark = Mark.create(mark)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'add_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert a `fragment` at `index` in a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} index\n * @param {Fragment} fragment\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertFragmentByKey = (change, key, index, fragment, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  fragment.nodes.forEach((node, i) => {\n    change.insertNodeByKey(key, index + i, node)\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(key)\n  }\n}\n\n/**\n * Insert a `node` at `index` in a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} index\n * @param {Node} node\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertNodeByKey = (change, key, index, node, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n\n  change.applyOperation({\n    type: 'insert_node',\n    value,\n    path: [...path, index],\n    node,\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(key)\n  }\n}\n\n/**\n * Insert `text` at `offset` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.insertTextByKey = (change, key, offset, text, marks, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  marks = marks || node.getMarksAtIndex(offset)\n\n  change.applyOperation({\n    type: 'insert_text',\n    value,\n    path,\n    offset,\n    text,\n    marks,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Merge a node by `key` with the previous node.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.mergeNodeByKey = (change, key, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const original = document.getDescendant(key)\n  const previous = document.getPreviousSibling(key)\n\n  if (!previous) {\n    throw new Error(`Unable to merge node with key \"${key}\", no previous key.`)\n  }\n\n  const position =\n    previous.object == 'text' ? previous.text.length : previous.nodes.size\n\n  change.applyOperation({\n    type: 'merge_node',\n    value,\n    path,\n    position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data,\n    },\n    target: null,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Move a node by `key` to a new parent by `newKey` and `index`.\n * `newKey` is the key of the container (it can be the document itself)\n *\n * @param {Change} change\n * @param {String} key\n * @param {String} newKey\n * @param {Number} index\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.moveNodeByKey = (change, key, newKey, newIndex, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const newPath = document.getPath(newKey)\n\n  change.applyOperation({\n    type: 'move_node',\n    value,\n    path,\n    newPath: [...newPath, newIndex],\n  })\n\n  if (normalize) {\n    const parent = document.getCommonAncestor(key, newKey)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Remove mark from text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeMarkByKey = (change, key, offset, length, mark, options = {}) => {\n  mark = Mark.create(mark)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  const leaves = node.getLeaves()\n\n  const operations = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the operation, continue on.\n    if (ay < bx || by < ax) return\n\n    // If the leaf already has the mark, continue on.\n    if (!leaf.marks.has(mark)) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n\n    operations.push({\n      type: 'remove_mark',\n      value,\n      path,\n      offset: start,\n      length: end - start,\n      mark,\n    })\n  })\n\n  change.applyOperations(operations)\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Remove all `marks` from node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeAllMarksByKey = (change, key, options = {}) => {\n  const { state } = change\n  const { document } = state\n  const node = document.getNode(key)\n  const texts = node.object === 'text' ? [node] : node.getTextsAsArray()\n\n  texts.forEach(text => {\n    text.getMarksAsArray().forEach(mark => {\n      change.removeMarkByKey(text.key, 0, text.text.length, mark, options)\n    })\n  })\n}\n\n/**\n * Remove a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeNodeByKey = (change, key, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n\n  change.applyOperation({\n    type: 'remove_node',\n    value,\n    path,\n    node,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Insert `text` at `offset` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setTextByKey = (change, key, text, marks, options = {}) => {\n  const textNode = change.value.document.getDescendant(key)\n  change.replaceTextByKey(key, 0, textNode.text.length, text, marks, options)\n}\n\n/**\n * Replace A Length of Text with another string or text\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n * @param {Object} options\n *   @property {Boolean} normalize\n *\n */\n\nChanges.replaceTextByKey = (\n  change,\n  key,\n  offset,\n  length,\n  text,\n  marks,\n  options\n) => {\n  const { document } = change.value\n  const textNode = document.getDescendant(key)\n\n  if (length + offset > textNode.text.length) {\n    length = textNode.text.length - offset\n  }\n\n  const range = Range.create({\n    anchorKey: key,\n    focusKey: key,\n    anchorOffset: offset,\n    focusOffset: offset + length,\n  })\n  let activeMarks = document.getActiveMarksAtRange(range)\n\n  change.removeTextByKey(key, offset, length, { normalize: false })\n\n  if (!marks) {\n    // Do not use mark at index when marks and activeMarks are both empty\n    marks = activeMarks ? activeMarks : []\n  } else if (activeMarks) {\n    // Do not use `has` because we may want to reset marks like font-size with an updated data;\n    activeMarks = activeMarks.filter(\n      activeMark => !marks.find(m => activeMark.type === m.type)\n    )\n\n    marks = activeMarks.merge(marks)\n  }\n\n  change.insertTextByKey(key, offset, text, marks, options)\n}\n\n/**\n * Remove text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.removeTextByKey = (change, key, offset, length, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n  const leaves = node.getLeaves()\n  const { text } = node\n\n  const removals = []\n  const bx = offset\n  const by = offset + length\n  let o = 0\n\n  leaves.forEach(leaf => {\n    const ax = o\n    const ay = ax + leaf.text.length\n\n    o += leaf.text.length\n\n    // If the leaf doesn't overlap with the removal, continue on.\n    if (ay < bx || by < ax) return\n\n    // Otherwise, determine which offset and characters overlap.\n    const start = Math.max(ax, bx)\n    const end = Math.min(ay, by)\n    const string = text.slice(start, end)\n\n    removals.push({\n      type: 'remove_text',\n      value,\n      path,\n      offset: start,\n      text: string,\n      marks: leaf.marks,\n    })\n  })\n\n  // Apply in reverse order, so subsequent removals don't impact previous ones.\n  change.applyOperations(removals.reverse())\n\n  if (normalize) {\n    const block = document.getClosestBlock(key)\n    change.normalizeNodeByKey(block.key)\n  }\n}\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|Node} node\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.replaceNodeByKey = (change, key, newNode, options = {}) => {\n  newNode = Node.create(newNode)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const node = document.getNode(key)\n  const parent = document.getParent(key)\n  const index = parent.nodes.indexOf(node)\n  change.removeNodeByKey(key, { normalize: false })\n  change.insertNodeByKey(parent.key, index, newNode, { normalize: false })\n\n  if (normalize) {\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Set `properties` on mark on text at `offset` and `length` in node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setMarkByKey = (\n  change,\n  key,\n  offset,\n  length,\n  mark,\n  properties,\n  options = {}\n) => {\n  mark = Mark.create(mark)\n  properties = Mark.createProperties(properties)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n\n  change.applyOperation({\n    type: 'set_mark',\n    value,\n    path,\n    offset,\n    length,\n    mark,\n    properties,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Set `properties` on a node by `key`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.setNodeByKey = (change, key, properties, options = {}) => {\n  properties = Node.createProperties(properties)\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getNode(key)\n\n  change.applyOperation({\n    type: 'set_node',\n    value,\n    path,\n    node,\n    properties,\n  })\n\n  if (normalize) {\n    change.normalizeNodeByKey(node.key)\n  }\n}\n\n/**\n * Split a node by `key` at `position`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} position\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitNodeByKey = (change, key, position, options = {}) => {\n  const { normalize = true, target = null } = options\n  const { value } = change\n  const { document } = value\n  const path = document.getPath(key)\n  const node = document.getDescendantAtPath(path)\n\n  change.applyOperation({\n    type: 'split_node',\n    value,\n    path,\n    position,\n    properties: {\n      type: node.type,\n      data: node.data,\n    },\n    target,\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Split a node deeply down the tree by `key`, `textKey` and `textOffset`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Number} position\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.splitDescendantsByKey = (\n  change,\n  key,\n  textKey,\n  textOffset,\n  options = {}\n) => {\n  if (key == textKey) {\n    change.splitNodeByKey(textKey, textOffset, options)\n    return\n  }\n\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n\n  const text = document.getNode(textKey)\n  const ancestors = document.getAncestors(textKey)\n  const nodes = ancestors\n    .skipUntil(a => a.key == key)\n    .reverse()\n    .unshift(text)\n  let previous\n  let index\n\n  nodes.forEach(node => {\n    const prevIndex = index == null ? null : index\n    index = previous ? node.nodes.indexOf(previous) + 1 : textOffset\n    previous = node\n\n    change.splitNodeByKey(node.key, index, {\n      normalize: false,\n      target: prevIndex,\n    })\n  })\n\n  if (normalize) {\n    const parent = document.getParent(key)\n    change.normalizeNodeByKey(parent.key)\n  }\n}\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapInlineByKey = (change, key, properties, options) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertDescendant(key)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOf(first, last)\n  change.unwrapInlineAtRange(range, properties, options)\n}\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object|String} properties\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapBlockByKey = (change, key, properties, options) => {\n  const { value } = change\n  const { document, selection } = value\n  const node = document.assertDescendant(key)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOf(first, last)\n  change.unwrapBlockAtRange(range, properties, options)\n}\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.unwrapNodeByKey = (change, key, options = {}) => {\n  const normalize = change.getFlag('normalize', options)\n  const { value } = change\n  const { document } = value\n  const parent = document.getParent(key)\n  const node = parent.getChild(key)\n\n  const index = parent.nodes.indexOf(node)\n  const isFirst = index === 0\n  const isLast = index === parent.nodes.size - 1\n\n  const parentParent = document.getParent(parent.key)\n  const parentIndex = parentParent.nodes.indexOf(parent)\n\n  if (parent.nodes.size === 1) {\n    change.moveNodeByKey(key, parentParent.key, parentIndex, {\n      normalize: false,\n    })\n\n    change.removeNodeByKey(parent.key, options)\n  } else if (isFirst) {\n    // Just move the node before its parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex, options)\n  } else if (isLast) {\n    // Just move the node after its parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex + 1, options)\n  } else {\n    // Split the parent.\n    change.splitNodeByKey(parent.key, index, { normalize: false })\n\n    // Extract the node in between the splitted parent.\n    change.moveNodeByKey(key, parentParent.key, parentIndex + 1, {\n      normalize: false,\n    })\n\n    if (normalize) {\n      change.normalizeNodeByKey(parentParent.key)\n    }\n  }\n}\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Change} change\n * @param {String} key The node to wrap\n * @param {Block|Object|String} block The wrapping block (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapBlockByKey = (change, key, block, options) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const { document } = change.value\n  const node = document.assertDescendant(key)\n  const parent = document.getParent(node.key)\n  const index = parent.nodes.indexOf(node)\n\n  change.insertNodeByKey(parent.key, index, block, { normalize: false })\n  change.moveNodeByKey(node.key, block.key, 0, options)\n}\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Change} change\n * @param {String} key The node to wrap\n * @param {Block|Object|String} inline The wrapping inline (its children are discarded)\n * @param {Object} options\n *   @property {Boolean} normalize\n */\n\nChanges.wrapInlineByKey = (change, key, inline, options) => {\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const { document } = change.value\n  const node = document.assertDescendant(key)\n  const parent = document.getParent(node.key)\n  const index = parent.nodes.indexOf(node)\n\n  change.insertNodeByKey(parent.key, index, inline, { normalize: false })\n  change.moveNodeByKey(node.key, inline.key, 0, options)\n}\n\n/**\n * Wrap a node by `key` with `parent`.\n *\n * @param {Change} change\n * @param {String} key\n * @param {Node|Object} parent\n * @param {Object} options\n */\n\nChanges.wrapNodeByKey = (change, key, parent) => {\n  parent = Node.create(parent)\n  parent = parent.set('nodes', parent.nodes.clear())\n\n  if (parent.object == 'block') {\n    change.wrapBlockByKey(key, parent)\n    return\n  }\n\n  if (parent.object == 'inline') {\n    change.wrapInlineByKey(key, parent)\n    return\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","/**\n * Slate operation attributes.\n *\n * @type {Array}\n */\n\nconst OPERATION_ATTRIBUTES = {\n  add_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  insert_node: ['value', 'path', 'node'],\n  insert_text: ['value', 'path', 'offset', 'text', 'marks'],\n  merge_node: ['value', 'path', 'position', 'properties', 'target'],\n  move_node: ['value', 'path', 'newPath'],\n  remove_mark: ['value', 'path', 'offset', 'length', 'mark'],\n  remove_node: ['value', 'path', 'node'],\n  remove_text: ['value', 'path', 'offset', 'text', 'marks'],\n  set_mark: ['value', 'path', 'offset', 'length', 'mark', 'properties'],\n  set_node: ['value', 'path', 'node', 'properties'],\n  set_selection: ['value', 'selection', 'properties'],\n  set_value: ['value', 'properties'],\n  split_node: ['value', 'path', 'position', 'properties', 'target'],\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default OPERATION_ATTRIBUTES\n","import Debug from 'debug'\nimport isEqual from 'lodash/isEqual'\nimport isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { List, Record, Stack } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:history')\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  redos: new Stack(),\n  undos: new Stack(),\n}\n\n/**\n * History.\n *\n * @type {History}\n */\n\nclass History extends Record(DEFAULTS) {\n  /**\n   * Create a new `History` with `attrs`.\n   *\n   * @param {Object|History} attrs\n   * @return {History}\n   */\n\n  static create(attrs = {}) {\n    if (History.isHistory(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return History.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`History.create\\` only accepts objects or histories, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `operations`.\n   *\n   * @param {Array<Object>|List<Object>} operations\n   * @return {List<Object>}\n   */\n\n  static createOperationsList(operations = []) {\n    if (List.isList(operations)) {\n      return operations\n    }\n\n    if (Array.isArray(operations)) {\n      return new List(operations)\n    }\n\n    throw new Error(\n      `\\`History.createList\\` only accepts arrays or lists, but you passed it: ${operations}`\n    )\n  }\n\n  /**\n   * Create a `History` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {History}\n   */\n\n  static fromJS(object) {\n    const { redos = [], undos = [] } = object\n\n    const history = new History({\n      redos: new Stack(redos.map(this.createOperationsList)),\n      undos: new Stack(undos.map(this.createOperationsList)),\n    })\n\n    return history\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return History.fromJS(object)\n  }\n\n  /**\n   * Check if `any` is a `History`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isHistory = isType.bind(null, 'HISTORY')\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'history'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Save an `operation` into the history.\n   *\n   * @param {Object} operation\n   * @param {Object} options\n   * @return {History}\n   */\n\n  save(operation, options = {}) {\n    let history = this\n    let { undos, redos } = history\n    let { merge, skip } = options\n    const prevBatch = undos.peek()\n    const prevOperation = prevBatch && prevBatch.last()\n\n    if (skip == null) {\n      skip = shouldSkip(operation, prevOperation)\n    }\n\n    if (skip) {\n      return history\n    }\n\n    if (merge == null) {\n      merge = shouldMerge(operation, prevOperation)\n    }\n\n    debug('save', { operation, merge })\n\n    // If the `merge` flag is true, add the operation to the previous batch.\n    if (merge && prevBatch) {\n      const batch = prevBatch.push(operation)\n      undos = undos.pop()\n      undos = undos.push(batch)\n    } else {\n      // Otherwise, create a new batch with the operation.\n      const batch = new List([operation])\n      undos = undos.push(batch)\n    }\n\n    // Constrain the history to 100 entries for memory's sake.\n    if (undos.size > 100) {\n      undos = undos.take(100)\n    }\n\n    // Clear the redos and update the history.\n    redos = redos.clear()\n    history = history.set('undos', undos).set('redos', redos)\n    return history\n  }\n\n  /**\n   * Return a JSON representation of the history.\n   *\n   * @return {Object}\n   */\n\n  toJS() {\n    const object = {\n      object: this.object,\n      redos: this.redos.toJS(),\n      undos: this.undos.toJS(),\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJSON() {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS()\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nHistory.prototype[MODEL_TYPES.HISTORY] = true\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false\n\n  const merge =\n    (o.type == 'set_selection' && p.type == 'set_selection') ||\n    (o.type == 'insert_text' &&\n      p.type == 'insert_text' &&\n      o.offset == p.offset + p.text.length &&\n      isEqual(o.path, p.path)) ||\n    (o.type == 'remove_text' &&\n      p.type == 'remove_text' &&\n      o.offset + o.text.length == p.offset &&\n      isEqual(o.path, p.path))\n\n  return merge\n}\n\n/**\n * Check whether to skip a new operation `o`, given previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldSkip(o, p) {\n  if (!p) return false\n\n  const skip = o.type == 'set_selection' && p.type == 'set_selection'\n\n  return skip\n}\n\n/**\n * Export.\n *\n * @type {History}\n */\n\nexport default History\n","import { List } from 'immutable'\n\nimport Text from '../models/text'\n\n/**\n * Define the core schema rules, order-sensitive.\n *\n * @type {Array}\n */\n\nconst CORE_SCHEMA_RULES = [\n  /**\n   * Only allow block nodes in documents.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'document') return\n      const invalids = node.nodes.filter(n => n.object != 'block')\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Only allow block nodes or inline and text nodes in blocks.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block') return\n      const first = node.nodes.first()\n      if (!first) return\n      const objects = first.object == 'block' ? ['block'] : ['inline', 'text']\n      const invalids = node.nodes.filter(n => !objects.includes(n.object))\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Only allow inline and text nodes in inlines.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'inline') return\n      const invalids = node.nodes.filter(\n        n => n.object != 'inline' && n.object != 'text'\n      )\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Ensure that block and inline nodes have at least one text child.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n      if (node.nodes.size > 0) return\n\n      return change => {\n        const text = Text.create()\n        change.insertNodeByKey(node.key, 0, text, { normalize: false })\n      }\n    },\n  },\n\n  /**\n   * Ensure that inline non-void nodes are never empty.\n   *\n   * This rule is applied to all blocks and inlines, because when they contain an empty\n   * inline, we need to remove the empty inline from that parent node. If `validate`\n   * was to be memoized, it should be against the parent node, not the empty inline itself.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'inline' && node.object != 'block') return\n\n      const invalids = node.nodes.filter(\n        child => child.object === 'inline' && child.isEmpty\n      )\n\n      if (!invalids.size) return\n\n      return change => {\n        // If all of the block's nodes are invalid, insert an empty text node so\n        // that the selection will be preserved when they are all removed.\n        if (node.nodes.size == invalids.size) {\n          const text = Text.create()\n          change.insertNodeByKey(node.key, 1, text, { normalize: false })\n        }\n\n        invalids.forEach(child => {\n          change.removeNodeByKey(child.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Ensure that inline void nodes are surrounded by text nodes, by adding extra\n   * blank text nodes if necessary.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n\n      const invalids = node.nodes.reduce((list, child, index) => {\n        if (child.object !== 'inline') return list\n\n        const prev = index > 0 ? node.nodes.get(index - 1) : null\n        const next = node.nodes.get(index + 1)\n\n        // We don't test if \"prev\" is inline, since it has already been\n        // processed in the loop\n        const insertBefore = !prev\n        const insertAfter = !next || next.object == 'inline'\n\n        if (insertAfter || insertBefore) {\n          list = list.push({ insertAfter, insertBefore, index })\n        }\n\n        return list\n      }, new List())\n\n      if (!invalids.size) return\n\n      return change => {\n        // Shift for every text node inserted previously.\n        let shift = 0\n\n        invalids.forEach(({ index, insertAfter, insertBefore }) => {\n          if (insertBefore) {\n            change.insertNodeByKey(node.key, shift + index, Text.create(), {\n              normalize: false,\n            })\n\n            shift++\n          }\n\n          if (insertAfter) {\n            change.insertNodeByKey(node.key, shift + index + 1, Text.create(), {\n              normalize: false,\n            })\n\n            shift++\n          }\n        })\n      }\n    },\n  },\n\n  /**\n   * Merge adjacent text nodes.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n\n      const invalids = node.nodes\n        .map((child, i) => {\n          const next = node.nodes.get(i + 1)\n          if (child.object != 'text') return\n          if (!next || next.object != 'text') return\n          return next\n        })\n        .filter(Boolean)\n\n      if (!invalids.size) return\n\n      return change => {\n        // Reverse the list to handle consecutive merges, since the earlier nodes\n        // will always exist after each merge.\n        invalids.reverse().forEach(n => {\n          change.mergeNodeByKey(n.key, { normalize: false })\n        })\n      }\n    },\n  },\n\n  /**\n   * Prevent extra empty text nodes, except when adjacent to inline void nodes.\n   *\n   * @type {Object}\n   */\n\n  {\n    validateNode(node) {\n      if (node.object != 'block' && node.object != 'inline') return\n      const { nodes } = node\n      if (nodes.size <= 1) return\n\n      const invalids = nodes.filter((desc, i) => {\n        if (desc.object != 'text') return\n        if (desc.text.length > 0) return\n\n        const prev = i > 0 ? nodes.get(i - 1) : null\n        const next = nodes.get(i + 1)\n\n        // If it's the first node, and the next is a void, preserve it.\n        if (!prev && next.object == 'inline') return\n\n        // It it's the last node, and the previous is an inline, preserve it.\n        if (!next && prev.object == 'inline') return\n\n        // If it's surrounded by inlines, preserve it.\n        if (next && prev && next.object == 'inline' && prev.object == 'inline')\n          return\n\n        // Otherwise, remove it.\n        return true\n      })\n\n      if (!invalids.size) return\n\n      return change => {\n        invalids.forEach(text => {\n          change.removeNodeByKey(text.key, { normalize: false })\n        })\n      }\n    },\n  },\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default CORE_SCHEMA_RULES\n","import logger from '@gitbook/slate-dev-logger'\nimport { Record } from 'immutable'\nimport memoize from 'immutablejs-record-memoize'\n\nimport MODEL_TYPES from '../constants/model-types'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  plugins: [],\n}\n\n/**\n * Stack.\n *\n * @type {Stack}\n */\n\nclass Stack extends Record(DEFAULTS) {\n  /**\n   * Constructor.\n   *\n   * @param {Object} attrs\n   */\n\n  static create(attrs = {}) {\n    const { plugins = [] } = attrs\n    const stack = new Stack({ plugins })\n    return stack\n  }\n\n  /**\n   * Check if `any` is a `Stack`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isStack(any) {\n    return !!(any && any[MODEL_TYPES.STACK])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'stack'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Get all plugins with `property`.\n   *\n   * @param {String} property\n   * @return {Array}\n   */\n\n  getPluginsWith(property) {\n    return this.plugins.filter(plugin => plugin[property] != null)\n  }\n\n  /**\n   * Iterate the plugins with `property`, returning the first non-null value.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   */\n\n  find(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) return ret\n    }\n  }\n\n  /**\n   * Iterate the plugins with `property`, returning all the non-null values.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   * @return {Array}\n   */\n\n  map(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n    const array = []\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) array.push(ret)\n    }\n\n    return array\n  }\n\n  /**\n   * Iterate the plugins with `property`, breaking on any a non-null values.\n   *\n   * @param {String} property\n   * @param {Any} ...args\n   */\n\n  run(property, ...args) {\n    const plugins = this.getPluginsWith(property)\n\n    for (const plugin of plugins) {\n      const ret = plugin[property](...args)\n      if (ret != null) return\n    }\n  }\n\n  /**\n   * Iterate the plugins with `property`, reducing to a set of React children.\n   *\n   * @param {String} property\n   * @param {Object} props\n   * @param {Any} ...args\n   */\n\n  render(property, props, ...args) {\n    const plugins = this.getPluginsWith(property)\n    return plugins.reduceRight((children, plugin) => {\n      if (!plugin[property]) return children\n      const ret = plugin[property](props, ...args)\n      if (ret == null) return children\n      props.children = ret\n      return ret\n    }, props.children === undefined ? null : props.children)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nStack.prototype[MODEL_TYPES.STACK] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Stack.prototype, ['getPluginsWith'])\n\n/**\n * Export.\n *\n * @type {Stack}\n */\n\nexport default Stack\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport mergeWith from 'lodash/mergeWith'\nimport { Record } from 'immutable'\nimport memoize from 'immutablejs-record-memoize'\n\nimport {\n  CHILD_OBJECT_INVALID,\n  CHILD_REQUIRED,\n  CHILD_TYPE_INVALID,\n  CHILD_UNKNOWN,\n  FIRST_CHILD_OBJECT_INVALID,\n  FIRST_CHILD_TYPE_INVALID,\n  LAST_CHILD_OBJECT_INVALID,\n  LAST_CHILD_TYPE_INVALID,\n  NODE_DATA_INVALID,\n  NODE_IS_VOID_INVALID,\n  NODE_MARK_INVALID,\n  NODE_TEXT_INVALID,\n  PARENT_OBJECT_INVALID,\n  PARENT_TYPE_INVALID,\n} from '@gitbook/slate-schema-violations'\n\nimport CORE_SCHEMA_RULES from '../constants/core-schema-rules'\nimport MODEL_TYPES from '../constants/model-types'\nimport Stack from './stack'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:schema')\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  stack: Stack.create(),\n  document: {},\n  blocks: {},\n  inlines: {},\n}\n\n/**\n * Schema.\n *\n * @type {Schema}\n */\n\nclass Schema extends Record(DEFAULTS) {\n  /**\n   * Create a new `Schema` with `attrs`.\n   *\n   * @param {Object|Schema} attrs\n   * @return {Schema}\n   */\n\n  static create(attrs = {}) {\n    if (Schema.isSchema(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Schema.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`Schema.create\\` only accepts objects or schemas, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Schema` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Schema}\n   */\n\n  static fromJS(object) {\n    if (Schema.isSchema(object)) {\n      return object\n    }\n\n    let { plugins } = object\n\n    if (object.rules) {\n      throw new Error(\n        'Schemas in Slate have changed! They are no longer accept a `rules` property.'\n      )\n    }\n\n    if (object.nodes) {\n      throw new Error(\n        'Schemas in Slate have changed! They are no longer accept a `nodes` property.'\n      )\n    }\n\n    if (!plugins) {\n      plugins = [{ schema: object }]\n    }\n\n    const schema = resolveSchema(plugins)\n    const stack = Stack.create({ plugins: [...CORE_SCHEMA_RULES, ...plugins] })\n    const ret = new Schema({ ...schema, stack })\n    return ret\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Schema.fromJS(object)\n  }\n\n  /**\n   * Check if `any` is a `Schema`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isSchema(any) {\n    return !!(any && any[MODEL_TYPES.SCHEMA])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'schema'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Get the rule for an `object`.\n   *\n   * @param {Mixed} object\n   * @return {Object}\n   */\n\n  getRule(object) {\n    switch (object.object) {\n      case 'document':\n        return this.document\n      case 'block':\n        return this.blocks[object.type]\n      case 'inline':\n        return this.inlines[object.type]\n    }\n  }\n\n  /**\n   * Get a dictionary of the parent rule validations by child type.\n   *\n   * @return {Object|Null}\n   */\n\n  getParentRules() {\n    const { blocks, inlines } = this\n    const parents = {}\n\n    for (const key in blocks) {\n      const rule = blocks[key]\n      if (rule.parent == null) continue\n      parents[key] = rule\n    }\n\n    for (const key in inlines) {\n      const rule = inlines[key]\n      if (rule.parent == null) continue\n      parents[key] = rule\n    }\n\n    return Object.keys(parents).length == 0 ? null : parents\n  }\n\n  /**\n   * Fail validation by returning a normalizing change function.\n   *\n   * @param {String} violation\n   * @param {Object} context\n   * @return {Function}\n   */\n\n  fail(violation, context) {\n    return change => {\n      debug(`normalizing`, { violation, context })\n      const { rule } = context\n      const { size } = change.operations\n      if (rule.normalize) rule.normalize(change, violation, context)\n      if (change.operations.size > size) return\n      this.normalize(change, violation, context)\n    }\n  }\n\n  /**\n   * Normalize an invalid value with `violation` and `context`.\n   *\n   * @param {Change} change\n   * @param {String} violation\n   * @param {Mixed} context\n   */\n\n  normalize(change, violation, context) {\n    switch (violation) {\n      case CHILD_OBJECT_INVALID:\n      case CHILD_TYPE_INVALID:\n      case CHILD_UNKNOWN:\n      case FIRST_CHILD_OBJECT_INVALID:\n      case FIRST_CHILD_TYPE_INVALID:\n      case LAST_CHILD_OBJECT_INVALID:\n      case LAST_CHILD_TYPE_INVALID: {\n        const { child, node } = context\n        return child.object == 'text' &&\n          node.object == 'block' &&\n          node.nodes.size == 1\n          ? change.removeNodeByKey(node.key)\n          : change.removeNodeByKey(child.key)\n      }\n\n      case CHILD_REQUIRED:\n      case NODE_TEXT_INVALID:\n      case PARENT_OBJECT_INVALID:\n      case PARENT_TYPE_INVALID: {\n        const { node } = context\n        return node.object == 'document'\n          ? node.nodes.forEach(child => change.removeNodeByKey(child.key))\n          : change.removeNodeByKey(node.key)\n      }\n\n      case NODE_DATA_INVALID: {\n        const { node, key } = context\n        return node.data.get(key) === undefined && node.object != 'document'\n          ? change.removeNodeByKey(node.key)\n          : change.setNodeByKey(node.key, { data: node.data.delete(key) })\n      }\n\n      case NODE_IS_VOID_INVALID: {\n        const { node } = context\n        return change.setNodeByKey(node.key, { isVoid: !node.isVoid })\n      }\n\n      case NODE_MARK_INVALID: {\n        const { node, mark } = context\n        return node\n          .getTexts()\n          .forEach(t => change.removeMarkByKey(t.key, 0, t.text.length, mark))\n      }\n    }\n  }\n\n  /**\n   * Validate a `node` with the schema, returning a function that will fix the\n   * invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @return {Function|Void}\n   */\n\n  validateNode(node) {\n    const ret = this.stack.find('validateNode', node)\n    if (ret) return ret\n\n    if (node.object == 'text') return\n\n    const rule = this.getRule(node) || {}\n    const parents = this.getParentRules()\n    const ctx = { node, rule }\n\n    if (rule.isVoid != null) {\n      if (node.isVoid != rule.isVoid) {\n        return this.fail(NODE_IS_VOID_INVALID, ctx)\n      }\n    }\n\n    if (rule.data != null) {\n      for (const key in rule.data) {\n        const fn = rule.data[key]\n        const value = node.data.get(key)\n\n        if (!fn(value)) {\n          return this.fail(NODE_DATA_INVALID, { ...ctx, key, value })\n        }\n      }\n    }\n\n    if (rule.marks != null) {\n      const marks = node.getMarks().toArray()\n\n      for (const mark of marks) {\n        if (!rule.marks.some(def => def.type === mark.type)) {\n          return this.fail(NODE_MARK_INVALID, { ...ctx, mark })\n        }\n      }\n    }\n\n    if (rule.text != null) {\n      const { text } = node\n\n      if (!rule.text.test(text)) {\n        return this.fail(NODE_TEXT_INVALID, { ...ctx, text })\n      }\n    }\n\n    if (rule.first != null) {\n      const { objects, types } = rule.first\n      const child = node.nodes.first()\n\n      if (child && objects && !objects.includes(child.object)) {\n        return this.fail(FIRST_CHILD_OBJECT_INVALID, { ...ctx, child })\n      }\n\n      if (child && types && !types.includes(child.type)) {\n        return this.fail(FIRST_CHILD_TYPE_INVALID, { ...ctx, child })\n      }\n    }\n\n    if (rule.last != null) {\n      const { objects, types } = rule.last\n      const child = node.nodes.last()\n\n      if (child && objects && !objects.includes(child.object)) {\n        return this.fail(LAST_CHILD_OBJECT_INVALID, { ...ctx, child })\n      }\n\n      if (child && types && !types.includes(child.type)) {\n        return this.fail(LAST_CHILD_TYPE_INVALID, { ...ctx, child })\n      }\n    }\n\n    if (rule.nodes != null || parents != null) {\n      const children = node.nodes.toArray()\n      const defs = rule.nodes != null ? rule.nodes.slice() : []\n\n      let offset\n      let min\n      let index\n      let def\n      let max\n      let child\n\n      function nextDef() {\n        offset = offset == null ? null : 0\n        def = defs.shift()\n        min = def && (def.min == null ? 0 : def.min)\n        max = def && (def.max == null ? Infinity : def.max)\n        return !!def\n      }\n\n      function nextChild() {\n        index = index == null ? 0 : index + 1\n        offset = offset == null ? 0 : offset + 1\n        child = children[index]\n        if (max != null && offset == max) nextDef()\n        return !!child\n      }\n\n      function rewind() {\n        offset -= 1\n        index -= 1\n      }\n\n      if (rule.nodes != null) {\n        nextDef()\n      }\n\n      while (nextChild()) {\n        if (\n          parents != null &&\n          child.object != 'text' &&\n          child.type in parents\n        ) {\n          const r = parents[child.type]\n\n          if (\n            r.parent.objects != null &&\n            !r.parent.objects.includes(node.object)\n          ) {\n            return this.fail(PARENT_OBJECT_INVALID, {\n              node: child,\n              parent: node,\n              rule: r,\n            })\n          }\n\n          if (r.parent.types != null && !r.parent.types.includes(node.type)) {\n            return this.fail(PARENT_TYPE_INVALID, {\n              node: child,\n              parent: node,\n              rule: r,\n            })\n          }\n        }\n\n        if (rule.nodes != null) {\n          if (!def) {\n            return this.fail(CHILD_UNKNOWN, { ...ctx, child, index })\n          }\n\n          if (def.objects != null && !def.objects.includes(child.object)) {\n            if (offset >= min && nextDef()) {\n              rewind()\n              continue\n            }\n            return this.fail(CHILD_OBJECT_INVALID, { ...ctx, child, index })\n          }\n\n          if (def.types != null && !def.types.includes(child.type)) {\n            if (offset >= min && nextDef()) {\n              rewind()\n              continue\n            }\n            return this.fail(CHILD_TYPE_INVALID, { ...ctx, child, index })\n          }\n        }\n      }\n\n      if (rule.nodes != null) {\n        while (min != null) {\n          if (offset < min) {\n            return this.fail(CHILD_REQUIRED, { ...ctx, index })\n          }\n\n          nextDef()\n        }\n      }\n    }\n  }\n\n  /**\n   * Return a JSON representation of the schema.\n   *\n   * @return {Object}\n   */\n\n  toJS() {\n    const object = {\n      object: this.object,\n      document: this.document,\n      blocks: this.blocks,\n      inlines: this.inlines,\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJSON() {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS()\n  }\n}\n\n/**\n * Resolve a set of schema rules from an array of `plugins`.\n *\n * @param {Array} plugins\n * @return {Object}\n */\n\nfunction resolveSchema(plugins = []) {\n  const schema = {\n    document: {},\n    blocks: {},\n    inlines: {},\n  }\n\n  plugins\n    .slice()\n    .reverse()\n    .forEach(plugin => {\n      if (!plugin.schema) return\n\n      if (plugin.schema.rules) {\n        throw new Error(\n          'Schemas in Slate have changed! They are no longer accept a `rules` property.'\n        )\n      }\n\n      if (plugin.schema.nodes) {\n        throw new Error(\n          'Schemas in Slate have changed! They are no longer accept a `nodes` property.'\n        )\n      }\n\n      const { document = {}, blocks = {}, inlines = {} } = plugin.schema\n      const d = resolveDocumentRule(document)\n      const bs = {}\n      const is = {}\n\n      for (const key in blocks) {\n        bs[key] = resolveNodeRule('block', key, blocks[key])\n      }\n\n      for (const key in inlines) {\n        is[key] = resolveNodeRule('inline', key, inlines[key])\n      }\n\n      mergeWith(schema.document, d, customizer)\n      mergeWith(schema.blocks, bs, customizer)\n      mergeWith(schema.inlines, is, customizer)\n    })\n\n  return schema\n}\n\n/**\n * Resolve a document rule `obj`.\n *\n * @param {Object} obj\n * @return {Object}\n */\n\nfunction resolveDocumentRule(obj) {\n  return {\n    data: {},\n    nodes: null,\n    ...obj,\n  }\n}\n\n/**\n * Resolve a node rule with `type` from `obj`.\n *\n * @param {String} object\n * @param {String} type\n * @param {Object} obj\n * @return {Object}\n */\n\nfunction resolveNodeRule(object, type, obj) {\n  return {\n    data: {},\n    isVoid: null,\n    nodes: null,\n    first: null,\n    last: null,\n    parent: null,\n    text: null,\n    ...obj,\n  }\n}\n\n/**\n * A Lodash customizer for merging schema definitions. Special cases `objects`,\n * `marks` and `types` arrays to be unioned, and ignores new `null` values.\n *\n * @param {Mixed} target\n * @param {Mixed} source\n * @return {Array|Void}\n */\n\nfunction customizer(target, source, key) {\n  if (key == 'objects' || key == 'types' || key == 'marks') {\n    return target == null ? source : target.concat(source)\n  } else {\n    return source == null ? target : source\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nSchema.prototype[MODEL_TYPES.SCHEMA] = true\n\n/**\n * Memoize read methods.\n */\n\nmemoize(Schema.prototype, ['getParentRules'])\n\n/**\n * Export.\n *\n * @type {Schema}\n */\n\nexport default Schema\n","import isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { Record, Set, List, Map } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport Change from './change'\nimport Data from './data'\nimport Document from './document'\nimport History from './history'\nimport Range from './range'\nimport Schema from './schema'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: new Map(),\n  decorations: null,\n  document: Document.create(),\n  history: History.create(),\n  schema: Schema.create(),\n  selection: Range.create(),\n}\n\n/**\n * Value.\n *\n * @type {Value}\n */\n\nclass Value extends Record(DEFAULTS) {\n  /**\n   * Create a new `Value` with `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @param {Object} options\n   * @return {Value}\n   */\n\n  static create(attrs = {}, options = {}) {\n    if (Value.isValue(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Value.fromJS(attrs, options)\n    }\n\n    throw new Error(\n      `\\`Value.create\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable value properties from `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Value.isValue(attrs)) {\n      return {\n        data: attrs.data,\n        decorations: attrs.decorations,\n        schema: attrs.schema,\n      }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      if ('decorations' in attrs)\n        props.decorations = Range.createList(attrs.decorations)\n      if ('schema' in attrs) props.schema = Schema.create(attrs.schema)\n      return props\n    }\n\n    throw new Error(\n      `\\`Value.createProperties\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Value` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @param {Object} options\n   *   @property {Boolean} normalize\n   *   @property {Array} plugins\n   * @return {Value}\n   */\n\n  static fromJS(object, options = {}) {\n    let { document = {}, selection = {}, schema = {}, history = {} } = object\n\n    let data = new Map()\n\n    document = Document.fromJS(document)\n\n    // rebuild selection from anchorPath and focusPath if keys were dropped\n    const { anchorPath, focusPath, anchorKey, focusKey } = selection\n\n    if (anchorPath !== undefined && anchorKey === undefined) {\n      selection.anchorKey = document.assertPath(anchorPath).key\n    }\n\n    if (focusPath !== undefined && focusKey === undefined) {\n      selection.focusKey = document.assertPath(focusPath).key\n    }\n\n    selection = Range.fromJS(selection)\n    schema = Schema.fromJS(schema)\n    history = History.fromJS(history)\n\n    // Allow plugins to set a default value for `data`.\n    if (options.plugins) {\n      for (const plugin of options.plugins) {\n        if (plugin.data) data = data.merge(plugin.data)\n      }\n    }\n\n    // Then merge in the `data` provided.\n    if ('data' in object) {\n      data = data.merge(object.data)\n    }\n\n    if (selection.isUnset) {\n      const text = document.getFirstText()\n      if (text) selection = selection.collapseToStartOf(text)\n    }\n\n    let value = new Value({\n      data,\n      document,\n      selection,\n      schema,\n      history,\n    })\n\n    if (options.normalize !== false) {\n      value = value.change({ save: false }).normalize().value\n    }\n\n    return value\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Value.fromJS(object)\n  }\n\n  /**\n   * Check if a `value` is a `Value`.\n   *\n   * @param {Any} value\n   * @return {Boolean}\n   */\n\n  static isValue(value) {\n    return !!(value && value[MODEL_TYPES.VALUE])\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'value'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Are there undoable events?\n   *\n   * @return {Boolean}\n   */\n\n  get hasUndos() {\n    return this.history.undos.size > 0\n  }\n\n  /**\n   * Are there redoable events?\n   *\n   * @return {Boolean}\n   */\n\n  get hasRedos() {\n    return this.history.redos.size > 0\n  }\n\n  /**\n   * Is the current selection blurred?\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return this.selection.isBlurred\n  }\n\n  /**\n   * Is the current selection focused?\n   *\n   * @return {Boolean}\n   */\n\n  get isFocused() {\n    return this.selection.isFocused\n  }\n\n  /**\n   * Is the current selection collapsed?\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return this.selection.isCollapsed\n  }\n\n  /**\n   * Is the current selection expanded?\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return this.selection.isExpanded\n  }\n\n  /**\n   * Is the current selection backward?\n   *\n   * @return {Boolean} isBackward\n   */\n\n  get isBackward() {\n    return this.selection.isBackward\n  }\n\n  /**\n   * Is the current selection forward?\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    return this.selection.isForward\n  }\n\n  /**\n   * Get the current start key.\n   *\n   * @return {String}\n   */\n\n  get startKey() {\n    return this.selection.startKey\n  }\n\n  /**\n   * Get the current end key.\n   *\n   * @return {String}\n   */\n\n  get endKey() {\n    return this.selection.endKey\n  }\n\n  /**\n   * Get the current start offset.\n   *\n   * @return {String}\n   */\n\n  get startOffset() {\n    return this.selection.startOffset\n  }\n\n  /**\n   * Get the current end offset.\n   *\n   * @return {String}\n   */\n\n  get endOffset() {\n    return this.selection.endOffset\n  }\n\n  /**\n   * Get the current anchor key.\n   *\n   * @return {String}\n   */\n\n  get anchorKey() {\n    return this.selection.anchorKey\n  }\n\n  /**\n   * Get the current focus key.\n   *\n   * @return {String}\n   */\n\n  get focusKey() {\n    return this.selection.focusKey\n  }\n\n  /**\n   * Get the current anchor offset.\n   *\n   * @return {String}\n   */\n\n  get anchorOffset() {\n    return this.selection.anchorOffset\n  }\n\n  /**\n   * Get the current focus offset.\n   *\n   * @return {String}\n   */\n\n  get focusOffset() {\n    return this.selection.focusOffset\n  }\n\n  /**\n   * Get the current start text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get startBlock() {\n    return this.startKey && this.document.getClosestBlock(this.startKey)\n  }\n\n  /**\n   * Get the current end text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get endBlock() {\n    return this.endKey && this.document.getClosestBlock(this.endKey)\n  }\n\n  /**\n   * Get the current anchor text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get anchorBlock() {\n    return this.anchorKey && this.document.getClosestBlock(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get focusBlock() {\n    return this.focusKey && this.document.getClosestBlock(this.focusKey)\n  }\n\n  /**\n   * Get the current start text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get startInline() {\n    return this.startKey && this.document.getClosestInline(this.startKey)\n  }\n\n  /**\n   * Get the current end text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get endInline() {\n    return this.endKey && this.document.getClosestInline(this.endKey)\n  }\n\n  /**\n   * Get the current anchor text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get anchorInline() {\n    return this.anchorKey && this.document.getClosestInline(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get focusInline() {\n    return this.focusKey && this.document.getClosestInline(this.focusKey)\n  }\n\n  /**\n   * Get the current start text node.\n   *\n   * @return {Text}\n   */\n\n  get startText() {\n    return this.startKey && this.document.getDescendant(this.startKey)\n  }\n\n  /**\n   * Get the current end node.\n   *\n   * @return {Text}\n   */\n\n  get endText() {\n    return this.endKey && this.document.getDescendant(this.endKey)\n  }\n\n  /**\n   * Get the current anchor node.\n   *\n   * @return {Text}\n   */\n\n  get anchorText() {\n    return this.anchorKey && this.document.getDescendant(this.anchorKey)\n  }\n\n  /**\n   * Get the current focus node.\n   *\n   * @return {Text}\n   */\n\n  get focusText() {\n    return this.focusKey && this.document.getDescendant(this.focusKey)\n  }\n\n  /**\n   * Get the next block node.\n   *\n   * @return {Block}\n   */\n\n  get nextBlock() {\n    return this.endKey && this.document.getNextBlock(this.endKey)\n  }\n\n  /**\n   * Get the previous block node.\n   *\n   * @return {Block}\n   */\n\n  get previousBlock() {\n    return this.startKey && this.document.getPreviousBlock(this.startKey)\n  }\n\n  /**\n   * Get the next inline node.\n   *\n   * @return {Inline}\n   */\n\n  get nextInline() {\n    return this.endKey && this.document.getNextInline(this.endKey)\n  }\n\n  /**\n   * Get the previous inline node.\n   *\n   * @return {Inline}\n   */\n\n  get previousInline() {\n    return this.startKey && this.document.getPreviousInline(this.startKey)\n  }\n\n  /**\n   * Get the next text node.\n   *\n   * @return {Text}\n   */\n\n  get nextText() {\n    return this.endKey && this.document.getNextText(this.endKey)\n  }\n\n  /**\n   * Get the previous text node.\n   *\n   * @return {Text}\n   */\n\n  get previousText() {\n    return this.startKey && this.document.getPreviousText(this.startKey)\n  }\n\n  /**\n   * Get the characters in the current selection.\n   *\n   * @return {List<Character>}\n   */\n\n  get characters() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getCharactersAtRange(this.selection)\n  }\n\n  /**\n   * Get the marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get marks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks || this.document.getMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the active marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get activeMarks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks ||\n          this.document.getActiveMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the block nodes in the current selection.\n   *\n   * @return {List<Block>}\n   */\n\n  get blocks() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getBlocksAtRange(this.selection)\n  }\n\n  /**\n   * Get the fragment of the current selection.\n   *\n   * @return {Document}\n   */\n\n  get fragment() {\n    return this.selection.isUnset\n      ? Document.create()\n      : this.document.getFragmentAtRange(this.selection)\n  }\n\n  /**\n   * Get the inline nodes in the current selection.\n   *\n   * @return {List<Inline>}\n   */\n\n  get inlines() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getInlinesAtRange(this.selection)\n  }\n\n  /**\n   * Get the text nodes in the current selection.\n   *\n   * @return {List<Text>}\n   */\n\n  get texts() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getTextsAtRange(this.selection)\n  }\n\n  /**\n   * Check whether the selection is empty.\n   *\n   * @return {Boolean}\n   */\n\n  get isEmpty() {\n    if (this.isCollapsed) return true\n    if (this.endOffset != 0 && this.startOffset != 0) return false\n    return this.fragment.isEmpty\n  }\n\n  /**\n   * Check whether the selection is collapsed in a void node.\n   *\n   * @return {Boolean}\n   */\n\n  get isInVoid() {\n    if (this.isExpanded) return false\n    return this.document.hasVoidParent(this.startKey)\n  }\n\n  /**\n   * Create a new `Change` with the current value as a starting point.\n   *\n   * @param {Object} attrs\n   * @return {Change}\n   */\n\n  change(attrs = {}) {\n    return new Change({ ...attrs, value: this })\n  }\n\n  /**\n   * Return a JSON representation of the value.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJS(options = {}) {\n    const object = {\n      object: this.object,\n      document: this.document.toJS(options),\n    }\n\n    if (options.preserveData) {\n      object.data = this.data.toJS()\n    }\n\n    if (options.preserveDecorations) {\n      object.decorations = this.decorations\n        ? this.decorations.toArray().map(d => d.toJS())\n        : null\n    }\n\n    if (options.preserveHistory) {\n      object.history = this.history.toJS()\n    }\n\n    if (options.preserveSelection) {\n      object.selection = this.selection.toJS()\n    }\n\n    if (options.preserveSchema) {\n      object.schema = this.schema.toJS()\n    }\n\n    if (options.preserveSelection && !options.preserveKeys) {\n      const { document, selection } = this\n\n      object.selection.anchorPath = selection.isSet\n        ? document.getPath(selection.anchorKey)\n        : null\n\n      object.selection.focusPath = selection.isSet\n        ? document.getPath(selection.focusKey)\n        : null\n\n      delete object.selection.anchorKey\n      delete object.selection.focusKey\n    }\n\n    if (\n      options.preserveDecorations &&\n      object.decorations &&\n      !options.preserveKeys\n    ) {\n      const { document } = this\n\n      object.decorations = object.decorations.map(decoration => {\n        const withPath = {\n          ...decoration,\n          anchorPath: document.getPath(decoration.anchorKey),\n          focusPath: document.getPath(decoration.focusKey),\n        }\n        delete withPath.anchorKey\n        delete withPath.focusKey\n        return withPath\n      })\n    }\n\n    return object\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJSON(options) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nValue.prototype[MODEL_TYPES.VALUE] = true\n\n/**\n * Export.\n */\n\nexport default Value\n","import isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport { List, Record } from 'immutable'\n\nimport MODEL_TYPES from '../constants/model-types'\nimport OPERATION_ATTRIBUTES from '../constants/operation-attributes'\nimport Mark from './mark'\nimport Node from './node'\nimport Range from './range'\nimport Value from './value'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  selection: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined,\n  value: undefined,\n}\n\n/**\n * Operation.\n *\n * @type {Operation}\n */\n\nclass Operation extends Record(DEFAULTS) {\n  /**\n   * Create a new `Operation` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Operation} attrs\n   * @return {Operation}\n   */\n\n  static create(attrs = {}) {\n    if (Operation.isOperation(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Operation.fromJS(attrs)\n    }\n\n    throw new Error(\n      `\\`Operation.create\\` only accepts objects or operations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `elements`.\n   *\n   * @param {Array<Operation|Object>|List<Operation|Object>} elements\n   * @return {List<Operation>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Operation.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Operation.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Operation` from a JSON `object`.\n   *\n   * @param {Object|Operation} object\n   * @return {Operation}\n   */\n\n  static fromJS(object) {\n    if (Operation.isOperation(object)) {\n      return object\n    }\n\n    const { type, value } = object\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n    const attrs = { type }\n\n    if (!ATTRIBUTES) {\n      throw new Error(\n        `\\`Operation.fromJS\\` was passed an unrecognized operation type: \"${type}\"`\n      )\n    }\n\n    for (const key of ATTRIBUTES) {\n      let v = object[key]\n\n      if (v === undefined) {\n        // Skip keys for objects that should not be serialized, and are only used\n        // for providing the local-only invert behavior for the history stack.\n        if (key == 'document') continue\n        if (key == 'selection') continue\n        if (key == 'value') continue\n        if (key == 'node' && type != 'insert_node') continue\n\n        throw new Error(\n          `\\`Operation.fromJS\\` was passed a \"${type}\" operation without the required \"${key}\" attribute.`\n        )\n      }\n\n      if (key == 'mark') {\n        v = Mark.create(v)\n      }\n\n      if (key == 'marks' && v != null) {\n        v = Mark.createSet(v)\n      }\n\n      if (key == 'node') {\n        v = Node.create(v)\n      }\n\n      if (key == 'selection') {\n        v = Range.create(v)\n      }\n\n      if (key == 'value') {\n        v = Value.create(v)\n      }\n\n      if (key == 'properties' && type == 'merge_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'set_mark') {\n        v = Mark.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'set_node') {\n        v = Node.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'set_selection') {\n        const { anchorKey, focusKey, ...rest } = v\n        v = Range.createProperties(rest)\n\n        if (anchorKey !== undefined) {\n          v.anchorPath =\n            anchorKey === null ? null : value.document.getPath(anchorKey)\n        }\n\n        if (focusKey !== undefined) {\n          v.focusPath =\n            focusKey === null ? null : value.document.getPath(focusKey)\n        }\n      }\n\n      if (key == 'properties' && type == 'set_value') {\n        v = Value.createProperties(v)\n      }\n\n      if (key == 'properties' && type == 'split_node') {\n        v = Node.createProperties(v)\n      }\n\n      attrs[key] = v\n    }\n\n    const node = new Operation(attrs)\n    return node\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJSON(object) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'fromJSON methods are deprecated, use fromJS instead'\n    )\n    return Operation.fromJS(object)\n  }\n\n  /**\n   * Check if `any` is a `Operation`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperation(any) {\n    return !!(any && any[MODEL_TYPES.OPERATION])\n  }\n\n  /**\n   * Check if `any` is a listof operations.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperationList(any) {\n    return List.isList(any) && any.every(item => Operation.isOperation(item))\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'operation'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Return a JSON representation of the operation.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJS(options = {}) {\n    const { object, type } = this\n    const json = { object, type }\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n\n    for (const key of ATTRIBUTES) {\n      let value = this[key]\n\n      // Skip keys for objects that should not be serialized, and are only used\n      // for providing the local-only invert behavior for the history stack.\n      if (key == 'document') continue\n      if (key == 'selection') continue\n      if (key == 'value') continue\n      if (key == 'node' && type != 'insert_node') continue\n\n      if (key == 'mark' || key == 'marks' || key == 'node') {\n        value = value.toJS()\n      }\n\n      if (key == 'properties' && type == 'merge_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_mark') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('isVoid' in value) v.isVoid = value.isVoid\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_selection') {\n        const v = {}\n        if ('anchorOffset' in value) v.anchorOffset = value.anchorOffset\n        if ('anchorPath' in value) v.anchorPath = value.anchorPath\n        if ('focusOffset' in value) v.focusOffset = value.focusOffset\n        if ('focusPath' in value) v.focusPath = value.focusPath\n        if ('isBackward' in value) v.isBackward = value.isBackward\n        if ('isFocused' in value) v.isFocused = value.isFocused\n        if ('marks' in value)\n          v.marks = value.marks == null ? null : value.marks.toJS()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'set_value') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('decorations' in value) v.decorations = value.decorations.toJS()\n        if ('schema' in value) v.schema = value.schema.toJS()\n        value = v\n      }\n\n      if (key == 'properties' && type == 'split_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      json[key] = value\n    }\n\n    return json\n  }\n\n  /**\n   * Alias `toJSON`.\n   */\n\n  toJSON(options) {\n    logger.deprecate(\n      'slate@0.35.0',\n      'toJSON methods are deprecated, use toJS instead'\n    )\n    return this.toJS(options)\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nOperation.prototype[MODEL_TYPES.OPERATION] = true\n\n/**\n * Export.\n *\n * @type {Operation}\n */\n\nexport default Operation\n","import Debug from 'debug'\nimport pick from 'lodash/pick'\n\nimport Operation from '../models/operation'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:invert')\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  /**\n   * Insert node.\n   */\n\n  if (type == 'insert_node') {\n    const inverse = op.set('type', 'remove_node')\n    return inverse\n  }\n\n  /**\n   * Remove node.\n   */\n\n  if (type == 'remove_node') {\n    const inverse = op.set('type', 'insert_node')\n    return inverse\n  }\n\n  /**\n   * Move node.\n   */\n\n  if (type == 'move_node') {\n    const { newPath, path } = op\n    let inversePath = newPath\n    let inverseNewPath = path\n\n    const pathLast = path.length - 1\n    const newPathLast = newPath.length - 1\n\n    // If the node's old position was a left sibling of an ancestor of\n    // its new position, we need to adjust part of the path by -1.\n    if (\n      path.length < inversePath.length &&\n      path.slice(0, pathLast).every((e, i) => e == inversePath[i]) &&\n      path[pathLast] < inversePath[pathLast]\n    ) {\n      inversePath = inversePath\n        .slice(0, pathLast)\n        .concat([inversePath[pathLast] - 1])\n        .concat(inversePath.slice(pathLast + 1, inversePath.length))\n    }\n\n    // If the node's new position is an ancestor of the old position,\n    // or a left sibling of an ancestor of its old position, we need\n    // to adjust part of the path by 1.\n    if (\n      newPath.length < inverseNewPath.length &&\n      newPath.slice(0, newPathLast).every((e, i) => e == inverseNewPath[i]) &&\n      newPath[newPathLast] <= inverseNewPath[newPathLast]\n    ) {\n      inverseNewPath = inverseNewPath\n        .slice(0, newPathLast)\n        .concat([inverseNewPath[newPathLast] + 1])\n        .concat(inverseNewPath.slice(newPathLast + 1, inverseNewPath.length))\n    }\n\n    const inverse = op.set('path', inversePath).set('newPath', inverseNewPath)\n    return inverse\n  }\n\n  /**\n   * Merge node.\n   */\n\n  if (type == 'merge_node') {\n    const { path } = op\n    const { length } = path\n    const last = length - 1\n    const inversePath = path.slice(0, last).concat([path[last] - 1])\n    const inverse = op.set('type', 'split_node').set('path', inversePath)\n    return inverse\n  }\n\n  /**\n   * Split node.\n   */\n\n  if (type == 'split_node') {\n    const { path } = op\n    const { length } = path\n    const last = length - 1\n    const inversePath = path.slice(0, last).concat([path[last] + 1])\n    const inverse = op.set('type', 'merge_node').set('path', inversePath)\n    return inverse\n  }\n\n  /**\n   * Set node.\n   */\n\n  if (type == 'set_node') {\n    const { properties, node } = op\n    const inverseNode = node.merge(properties)\n    const inverseProperties = pick(node, Object.keys(properties))\n    const inverse = op\n      .set('node', inverseNode)\n      .set('properties', inverseProperties)\n    return inverse\n  }\n\n  /**\n   * Insert text.\n   */\n\n  if (type == 'insert_text') {\n    const inverse = op.set('type', 'remove_text')\n    return inverse\n  }\n\n  /**\n   * Remove text.\n   */\n\n  if (type == 'remove_text') {\n    const inverse = op.set('type', 'insert_text')\n    return inverse\n  }\n\n  /**\n   * Add mark.\n   */\n\n  if (type == 'add_mark') {\n    const inverse = op.set('type', 'remove_mark')\n    return inverse\n  }\n\n  /**\n   * Remove mark.\n   */\n\n  if (type == 'remove_mark') {\n    const inverse = op.set('type', 'add_mark')\n    return inverse\n  }\n\n  /**\n   * Set mark.\n   */\n\n  if (type == 'set_mark') {\n    const { properties, mark } = op\n    const inverseMark = mark.merge(properties)\n    const inverseProperties = pick(mark, Object.keys(properties))\n    const inverse = op\n      .set('mark', inverseMark)\n      .set('properties', inverseProperties)\n    return inverse\n  }\n\n  /**\n   * Set selection.\n   */\n\n  if (type == 'set_selection') {\n    const { properties, selection, value } = op\n    const { anchorPath, focusPath, ...props } = properties\n    const { document } = value\n\n    if (anchorPath !== undefined) {\n      props.anchorKey =\n        anchorPath === null ? null : document.assertPath(anchorPath).key\n    }\n\n    if (focusPath !== undefined) {\n      props.focusKey =\n        focusPath === null ? null : document.assertPath(focusPath).key\n    }\n\n    const inverseSelection = selection.merge(props)\n    const inverseProps = pick(selection, Object.keys(props))\n\n    if (anchorPath !== undefined) {\n      inverseProps.anchorPath =\n        inverseProps.anchorKey === null\n          ? null\n          : document.getPath(inverseProps.anchorKey)\n\n      delete inverseProps.anchorKey\n    }\n\n    if (focusPath !== undefined) {\n      inverseProps.focusPath =\n        inverseProps.focusKey === null\n          ? null\n          : document.getPath(inverseProps.focusKey)\n\n      delete inverseProps.focusKey\n    }\n\n    const inverse = op\n      .set('selection', inverseSelection)\n      .set('properties', inverseProps)\n    return inverse\n  }\n\n  /**\n   * Set value.\n   */\n\n  if (type == 'set_value') {\n    const { properties, value } = op\n    const inverseValue = value.merge(properties)\n    const inverseProperties = pick(value, Object.keys(properties))\n    const inverse = op\n      .set('value', inverseValue)\n      .set('properties', inverseProperties)\n    return inverse\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default invertOperation\n","import invert from '../operations/invert'\nimport omit from 'lodash/omit'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Change} change\n */\n\nChanges.redo = change => {\n  let { value } = change\n  let { history } = value\n  if (!history) return\n\n  let { undos, redos } = history\n  const next = redos.peek()\n  if (!next) return\n\n  // Shift the next value into the undo stack.\n  redos = redos.pop()\n  undos = undos.push(next)\n\n  // Replay the next operations.\n  next.forEach(op => {\n    const { type, properties } = op\n\n    // When the operation mutates the selection, omit its `isFocused` value to\n    // prevent the editor focus from changing during redoing.\n    if (type == 'set_selection') {\n      op = op.set('properties', omit(properties, 'isFocused'))\n    }\n\n    change.applyOperation(op, { save: false })\n  })\n\n  // Update the history.\n  value = change.value\n  history = history.set('undos', undos).set('redos', redos)\n  value = value.set('history', history)\n  change.value = value\n}\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Change} change\n */\n\nChanges.undo = change => {\n  let { value } = change\n  let { history } = value\n  if (!history) return\n\n  let { undos, redos } = history\n  const previous = undos.peek()\n  if (!previous) return\n\n  // Shift the previous operations into the redo stack.\n  undos = undos.pop()\n  redos = redos.push(previous)\n\n  // Replay the inverse of the previous operations.\n  previous\n    .slice()\n    .reverse()\n    .map(invert)\n    .forEach(inverse => {\n      const { type, properties } = inverse\n\n      // When the operation mutates the selection, omit its `isFocused` value to\n      // prevent the editor focus from changing during undoing.\n      if (type == 'set_selection') {\n        inverse = inverse.set('properties', omit(properties, 'isFocused'))\n      }\n\n      change.applyOperation(inverse, { save: false })\n    })\n\n  // Update the history.\n  value = change.value\n  history = history.set('undos', undos).set('redos', redos)\n  value = value.set('history', history)\n  change.value = value\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import isEmpty from 'is-empty'\nimport pick from 'lodash/pick'\n\nimport Range from '../models/range'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Set `properties` on the selection.\n *\n * @param {Change} change\n * @param {Object} properties\n */\n\nChanges.select = (change, properties, options = {}) => {\n  properties = Range.createProperties(properties)\n\n  const { snapshot = false } = options\n  const { value } = change\n  const { document, selection } = value\n  const props = {}\n  const sel = selection.toJS()\n  const next = selection.merge(properties).normalize(document)\n  properties = pick(next, Object.keys(properties))\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (const k in properties) {\n    if (snapshot == false && properties[k] == sel[k]) continue\n    props[k] = properties[k]\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  const moved = ['anchorKey', 'anchorOffset', 'focusKey', 'focusOffset'].some(\n    p => props.hasOwnProperty(p)\n  )\n\n  if (sel.marks && properties.marks == sel.marks && moved) {\n    props.marks = null\n  }\n\n  // If there are no new properties to set, abort.\n  if (isEmpty(props)) {\n    return\n  }\n\n  // Apply the operation.\n  change.applyOperation(\n    {\n      type: 'set_selection',\n      value,\n      properties: props,\n      selection: sel,\n    },\n    snapshot ? { skip: false, merge: false } : {}\n  )\n}\n\n/**\n * Select the whole document.\n *\n * @param {Change} change\n */\n\nChanges.selectAll = change => {\n  const { value } = change\n  const { document, selection } = value\n  const next = selection.moveToRangeOf(document)\n  change.select(next)\n}\n\n/**\n * Snapshot the current selection.\n *\n * @param {Change} change\n */\n\nChanges.snapshotSelection = change => {\n  const { value } = change\n  const { selection } = value\n  change.select(selection, { snapshot: true })\n}\n\n/**\n * Move the anchor point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveAnchorCharBackward = change => {\n  const { value } = change\n  const { document, selection, anchorText, anchorBlock } = value\n  const { anchorOffset } = selection\n  const previousText = document.getPreviousText(anchorText.key)\n  const isInVoid = document.hasVoidParent(anchorText.key)\n  const isPreviousInVoid =\n    previousText && document.hasVoidParent(previousText.key)\n\n  if (!isInVoid && anchorOffset > 0) {\n    change.moveAnchor(-1)\n    return\n  }\n\n  if (!previousText) {\n    return\n  }\n\n  change.moveAnchorToEndOf(previousText)\n\n  if (!isInVoid && !isPreviousInVoid && anchorBlock.hasNode(previousText.key)) {\n    change.moveAnchor(-1)\n  }\n}\n\n/**\n * Move the anchor point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveAnchorCharForward = change => {\n  const { value } = change\n  const { document, selection, anchorText, anchorBlock } = value\n  const { anchorOffset } = selection\n  const nextText = document.getNextText(anchorText.key)\n  const isInVoid = document.hasVoidParent(anchorText.key)\n  const isNextInVoid = nextText && document.hasVoidParent(nextText.key)\n\n  if (!isInVoid && anchorOffset < anchorText.text.length) {\n    change.moveAnchor(1)\n    return\n  }\n\n  if (!nextText) {\n    return\n  }\n\n  change.moveAnchorToStartOf(nextText)\n\n  if (!isInVoid && !isNextInVoid && anchorBlock.hasNode(nextText.key)) {\n    change.moveAnchor(1)\n  }\n}\n\n/**\n * Move the focus point backward, accounting for being at the start of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveFocusCharBackward = change => {\n  const { value } = change\n  const { document, selection, focusText, focusBlock } = value\n  const { focusOffset } = selection\n  const previousText = document.getPreviousText(focusText.key)\n  const isInVoid = document.hasVoidParent(focusText.key)\n  const isPreviousInVoid =\n    previousText && document.hasVoidParent(previousText.key)\n\n  if (!isInVoid && focusOffset > 0) {\n    change.moveFocus(-1)\n    return\n  }\n\n  if (!previousText) {\n    return\n  }\n\n  change.moveFocusToEndOf(previousText)\n\n  if (!isInVoid && !isPreviousInVoid && focusBlock.hasNode(previousText.key)) {\n    change.moveFocus(-1)\n  }\n}\n\n/**\n * Move the focus point forward, accounting for being at the end of a block.\n *\n * @param {Change} change\n */\n\nChanges.moveFocusCharForward = change => {\n  const { value } = change\n  const { document, selection, focusText, focusBlock } = value\n  const { focusOffset } = selection\n  const nextText = document.getNextText(focusText.key)\n  const isInVoid = document.hasVoidParent(focusText.key)\n  const isNextInVoid = nextText && document.hasVoidParent(nextText.key)\n\n  if (!isInVoid && focusOffset < focusText.text.length) {\n    change.moveFocus(1)\n    return\n  }\n\n  if (!nextText) {\n    return\n  }\n\n  change.moveFocusToStartOf(nextText)\n\n  if (!isInVoid && !isNextInVoid && focusBlock.hasNode(nextText.key)) {\n    change.moveFocus(1)\n  }\n}\n\n/**\n * Mix in move methods.\n */\n\nconst MOVE_DIRECTIONS = ['Forward', 'Backward']\n\nMOVE_DIRECTIONS.forEach(direction => {\n  const anchor = `moveAnchorChar${direction}`\n  const focus = `moveFocusChar${direction}`\n\n  Changes[`moveChar${direction}`] = change => {\n    change[anchor]()[focus]()\n  }\n\n  Changes[`moveStartChar${direction}`] = change => {\n    if (change.value.isBackward) {\n      change[focus]()\n    } else {\n      change[anchor]()\n    }\n  }\n\n  Changes[`moveEndChar${direction}`] = change => {\n    if (change.value.isBackward) {\n      change[anchor]()\n    } else {\n      change[focus]()\n    }\n  }\n\n  Changes[`extendChar${direction}`] = change => {\n    change[`moveFocusChar${direction}`]()\n  }\n\n  Changes[`collapseChar${direction}`] = change => {\n    const collapse =\n      direction == 'Forward' ? 'collapseToEnd' : 'collapseToStart'\n    change[collapse]()[`moveChar${direction}`]()\n  }\n})\n\n/**\n * Mix in alias methods.\n */\n\nconst ALIAS_METHODS = [\n  ['collapseLineBackward', 'collapseToStartOfBlock'],\n  ['collapseLineForward', 'collapseToEndOfBlock'],\n  ['extendLineBackward', 'extendToStartOfBlock'],\n  ['extendLineForward', 'extendToEndOfBlock'],\n]\n\nALIAS_METHODS.forEach(([alias, method]) => {\n  Changes[alias] = function(change, ...args) {\n    change[method](change, ...args)\n  }\n})\n\n/**\n * Mix in selection changes that are just a proxy for the selection method.\n */\n\nconst PROXY_TRANSFORMS = [\n  'blur',\n  'collapseTo',\n  'collapseToAnchor',\n  'collapseToEnd',\n  'collapseToEndOf',\n  'collapseToFocus',\n  'collapseToStart',\n  'collapseToStartOf',\n  'extend',\n  'extendTo',\n  'extendToEndOf',\n  'extendToStartOf',\n  'flip',\n  'focus',\n  'move',\n  'moveAnchor',\n  'moveAnchorOffsetTo',\n  'moveAnchorTo',\n  'moveAnchorToEndOf',\n  'moveAnchorToStartOf',\n  'moveEnd',\n  'moveEndOffsetTo',\n  'moveEndTo',\n  'moveFocus',\n  'moveFocusOffsetTo',\n  'moveFocusTo',\n  'moveFocusToEndOf',\n  'moveFocusToStartOf',\n  'moveOffsetsTo',\n  'moveStart',\n  'moveStartOffsetTo',\n  'moveStartTo',\n  'moveTo',\n  'moveToEnd',\n  'moveToEndOf',\n  'moveToRangeOf',\n  'moveToStart',\n  'moveToStartOf',\n  'deselect',\n]\n\nPROXY_TRANSFORMS.forEach(method => {\n  Changes[method] = (change, ...args) => {\n    const normalize = method != 'deselect'\n    const { value } = change\n    const { document, selection } = value\n    let next = selection[method](...args)\n    if (normalize) next = next.normalize(document)\n    change.select(next)\n  }\n})\n\n/**\n * Mix in node-related changes.\n */\n\nconst PREFIXES = [\n  'moveTo',\n  'moveAnchorTo',\n  'moveFocusTo',\n  'moveStartTo',\n  'moveEndTo',\n  'collapseTo',\n  'extendTo',\n]\n\nconst DIRECTIONS = ['Next', 'Previous']\n\nconst OBJECTS = ['Block', 'Inline', 'Text']\n\nPREFIXES.forEach(prefix => {\n  const edges = ['Start', 'End']\n\n  if (prefix == 'moveTo') {\n    edges.push('Range')\n  }\n\n  edges.forEach(edge => {\n    const method = `${prefix}${edge}Of`\n\n    OBJECTS.forEach(object => {\n      const getNode = object == 'Text' ? 'getNode' : `getClosest${object}`\n\n      Changes[`${method}${object}`] = change => {\n        const { value } = change\n        const { document, selection } = value\n        const node = document[getNode](selection.startKey)\n        if (!node) return\n        change[method](node)\n      }\n\n      DIRECTIONS.forEach(direction => {\n        const getDirectionNode = `get${direction}${object}`\n        const directionKey = direction == 'Next' ? 'startKey' : 'endKey'\n\n        Changes[`${method}${direction}${object}`] = change => {\n          const { value } = change\n          const { document, selection } = value\n          const node = document[getNode](selection[directionKey])\n          if (!node) return\n          const target = document[getDirectionNode](node.key)\n          if (!target) return\n          change[method](target)\n        }\n      })\n    })\n  })\n})\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import Value from '../models/value'\n\n/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Set `properties` on the value.\n *\n * @param {Change} change\n * @param {Object|Value} properties\n * @param {Object} options\n */\n\nChanges.setValue = (change, properties, options = {}) => {\n  properties = Value.createProperties(properties)\n  const { value } = change\n\n  change.applyOperation(\n    {\n      type: 'set_value',\n      properties,\n      value,\n    },\n    options\n  )\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","/**\n * Changes.\n *\n * @type {Object}\n */\n\nconst Changes = {}\n\n/**\n * Normalize the value with its schema.\n *\n * @param {Change} change\n */\n\nChanges.normalize = change => {\n  change.normalizeDocument()\n}\n\n/**\n * Normalize the document with the value's schema.\n *\n * @param {Change} change\n */\n\nChanges.normalizeDocument = change => {\n  const { value } = change\n  const { document } = value\n  change.normalizeNodeByKey(document.key)\n}\n\n/**\n * Normalize a `node` and its children with the value's schema.\n *\n * @param {Change} change\n * @param {Node|String} key\n */\n\nChanges.normalizeNodeByKey = (change, key) => {\n  const { value } = change\n  let { document, schema } = value\n  const node = document.assertNode(key)\n\n  normalizeNodeAndChildren(change, node, schema)\n\n  document = change.value.document\n  const ancestors = document.getAncestors(key)\n  if (!ancestors) return\n\n  ancestors.forEach(ancestor => {\n    if (change.value.document.getDescendant(ancestor.key)) {\n      normalizeNode(change, ancestor, schema)\n    }\n  })\n}\n\n/**\n * Normalize a `node` and its children with a `schema`.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNodeAndChildren(change, node, schema) {\n  if (node.object == 'text') {\n    normalizeNode(change, node, schema)\n    return\n  }\n\n  let child = node.getFirstInvalidDescendant(schema)\n  let path = change.value.document.getPath(node.key)\n\n  while (node && child) {\n    normalizeNodeAndChildren(change, child, schema)\n    node = change.value.document.refindNode(path, node.key)\n\n    if (!node) {\n      path = []\n      child = null\n    } else {\n      path = change.value.document.refindPath(path, node.key)\n      child = node.getFirstInvalidDescendant(schema)\n    }\n  }\n\n  // Normalize the node itself if it still exists.\n  if (node) {\n    normalizeNode(change, node, schema)\n  }\n}\n\n/**\n * Normalize a `node` with a `schema`, but not its children.\n *\n * @param {Change} change\n * @param {Node} node\n * @param {Schema} schema\n */\n\nfunction normalizeNode(change, node, schema) {\n  const max = schema.stack.plugins.length + 1\n  let iterations = 0\n\n  function iterate(c, n) {\n    const normalize = n.validate(schema)\n    if (!normalize) return\n\n    // Run the `normalize` function to fix the node.\n    let path = c.value.document.getPath(n.key)\n    normalize(c)\n\n    // Re-find the node reference, in case it was updated. If the node no longer\n    // exists, we're done for this branch.\n    n = c.value.document.refindNode(path, n.key)\n    if (!n) return\n\n    path = c.value.document.refindPath(path, n.key)\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `validate` or\n    // `normalize` function of a schema rule to be written incorrectly and for\n    // an infinite invalid loop to occur.\n    iterations++\n\n    if (iterations > max) {\n      throw new Error(\n        'A schema rule could not be validated after sufficient iterations. This is usually due to a `rule.validate` or `rule.normalize` function of a schema being incorrectly written, causing an infinite loop.'\n      )\n    }\n\n    // Otherwise, iterate again.\n    iterate(c, n)\n  }\n\n  iterate(change, node)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Changes\n","import AtCurrentRange from './at-current-range'\nimport AtRange from './at-range'\nimport ByKey from './by-key'\nimport OnHistory from './on-history'\nimport OnSelection from './on-selection'\nimport OnValue from './on-value'\nimport WithSchema from './with-schema'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  ...AtCurrentRange,\n  ...AtRange,\n  ...ByKey,\n  ...OnHistory,\n  ...OnSelection,\n  ...OnValue,\n  ...WithSchema,\n}\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:apply')\n\n/**\n * Apply adjustments to affected ranges (selections, decorations);\n * accepts (value, checking function(range) -> bool, applying function(range) -> range)\n * returns value with affected ranges updated\n *\n * @param {Value} value\n * @param {Function} checkAffected\n * @param {Function} adjustRange\n * @return {Value}\n */\n\nfunction applyRangeAdjustments(value, checkAffected, adjustRange) {\n  // check selection, apply adjustment if affected\n  if (value.selection && checkAffected(value.selection)) {\n    value = value.set('selection', adjustRange(value.selection))\n  }\n\n  if (!value.decorations) return value\n\n  // check all ranges, apply adjustment if affected\n  const decorations = value.decorations\n    .map(\n      decoration =>\n        checkAffected(decoration) ? adjustRange(decoration) : decoration\n    )\n    .filter(decoration => decoration.anchorKey !== null)\n  return value.set('decorations', decorations)\n}\n\n/**\n * clear any atomic ranges (in decorations) if they contain the point (key, offset, offset-end?)\n * specified\n *\n * @param {Value} value\n * @param {String} key\n * @param {Number} offset\n * @param {Number?} offsetEnd\n * @return {Value}\n */\n\nfunction clearAtomicRangesIfContains(value, key, offset, offsetEnd = null) {\n  return applyRangeAdjustments(\n    value,\n    range => {\n      if (!range.isAtomic) return false\n      const { startKey, startOffset, endKey, endOffset } = range\n      return (\n        (startKey == key &&\n          startOffset < offset &&\n          (endKey != key || endOffset > offset)) ||\n        (offsetEnd &&\n          startKey == key &&\n          startOffset < offsetEnd &&\n          (endKey != key || endOffset > offsetEnd))\n      )\n    },\n    range => range.deselect()\n  )\n}\n\n/**\n * Applying functions.\n *\n * @type {Object}\n */\n\nconst APPLIERS = {\n  /**\n   * Add mark to text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  add_mark(value, operation) {\n    const { path, offset, length, mark } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.addMark(offset, length, mark)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Insert a `node` at `index` in a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  insert_node(value, operation) {\n    const { path, node } = operation\n    const index = path[path.length - 1]\n    const rest = path.slice(0, -1)\n    let { document } = value\n    let parent = document.assertPath(rest)\n    parent = parent.insertNode(index, node)\n    document = document.updateNode(parent)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  insert_text(value, operation) {\n    const { path, offset, text, marks } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n\n    // Update the document\n    node = node.insertText(offset, text, marks)\n    document = document.updateNode(node)\n\n    value = value.set('document', document)\n\n    // if insert happens within atomic ranges, clear\n    value = clearAtomicRangesIfContains(value, node.key, offset)\n\n    // Update the selection, decorations\n    value = applyRangeAdjustments(\n      value,\n      ({ anchorKey, anchorOffset, isBackward, isAtomic }) =>\n        anchorKey == node.key &&\n        (anchorOffset > offset ||\n          (anchorOffset == offset && (!isAtomic || !isBackward))),\n      range => range.moveAnchor(text.length)\n    )\n\n    value = applyRangeAdjustments(\n      value,\n      ({ focusKey, focusOffset, isBackward, isAtomic }) =>\n        focusKey == node.key &&\n        (focusOffset > offset ||\n          (focusOffset == offset && (!isAtomic || isBackward))),\n      range => range.moveFocus(text.length)\n    )\n\n    return value\n  },\n\n  /**\n   * Merge a node at `path` with the previous node.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  merge_node(value, operation) {\n    const { path } = operation\n    const withPath = path\n      .slice(0, path.length - 1)\n      .concat([path[path.length - 1] - 1])\n    let { document } = value\n    const one = document.assertPath(withPath)\n    const two = document.assertPath(path)\n    let parent = document.getParent(one.key)\n    const oneIndex = parent.nodes.indexOf(one)\n    const twoIndex = parent.nodes.indexOf(two)\n\n    // Perform the merge in the document.\n    parent = parent.mergeNode(oneIndex, twoIndex)\n    document = document.updateNode(parent)\n    value = value.set('document', document)\n\n    if (one.object == 'text') {\n      value = applyRangeAdjustments(\n        value,\n        // If the nodes are text nodes and the range is inside the second node:\n        ({ anchorKey, focusKey }) =>\n          anchorKey == two.key || focusKey == two.key,\n        // update it to refer to the first node instead:\n        range => {\n          if (range.anchorKey == two.key)\n            range = range.moveAnchorTo(\n              one.key,\n              one.text.length + range.anchorOffset\n            )\n          if (range.focusKey == two.key)\n            range = range.moveFocusTo(\n              one.key,\n              one.text.length + range.focusOffset\n            )\n          return range.normalize(document)\n        }\n      )\n    }\n\n    return value\n  },\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  move_node(value, operation) {\n    const { path, newPath } = operation\n    const newIndex = newPath[newPath.length - 1]\n    const newParentPath = newPath.slice(0, -1)\n    const oldParentPath = path.slice(0, -1)\n    const oldIndex = path[path.length - 1]\n    let { document } = value\n    const node = document.assertPath(path)\n\n    // Remove the node from its current parent.\n    let parent = document.getParent(node.key)\n    parent = parent.removeNode(oldIndex)\n    document = document.updateNode(parent)\n\n    // Find the new target...\n    let target\n\n    // If the old path and the rest of the new path are the same, then the new\n    // target is the old parent.\n    if (\n      oldParentPath.every((x, i) => x === newParentPath[i]) &&\n      oldParentPath.length === newParentPath.length\n    ) {\n      target = parent\n    } else if (\n      oldParentPath.every((x, i) => x === newParentPath[i]) &&\n      oldIndex < newParentPath[oldParentPath.length]\n    ) {\n      // Otherwise, if the old path removal resulted in the new path being no longer\n      // correct, we need to decrement the new path at the old path's last index.\n      newParentPath[oldParentPath.length]--\n      target = document.assertPath(newParentPath)\n    } else {\n      // Otherwise, we can just grab the target normally...\n      target = document.assertPath(newParentPath)\n    }\n\n    // Insert the new node to its new parent.\n    target = target.insertNode(newIndex, node)\n    document = document.updateNode(target)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Remove mark from text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_mark(value, operation) {\n    const { path, offset, length, mark } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.removeMark(offset, length, mark)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Remove a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_node(value, operation) {\n    const { path } = operation\n    let { document, selection } = value\n    const node = document.assertPath(path)\n\n    if (selection.isSet || value.decorations !== null) {\n      const first = node.object == 'text' ? node : node.getFirstText() || node\n      const last = node.object == 'text' ? node : node.getLastText() || node\n      const prev = document.getPreviousText(first.key)\n      const next = document.getNextText(last.key)\n\n      value = applyRangeAdjustments(\n        value,\n        // If the start or end point was in this node\n        ({ startKey, endKey }) =>\n          node.hasNode(startKey) || node.hasNode(endKey),\n        // update it to be just before/after\n        range => {\n          const { startKey, endKey } = range\n\n          if (node.hasNode(startKey)) {\n            range = prev\n              ? range.moveStartTo(prev.key, prev.text.length)\n              : next ? range.moveStartTo(next.key, 0) : range.deselect()\n          }\n\n          if (node.hasNode(endKey)) {\n            range = prev\n              ? range.moveEndTo(prev.key, prev.text.length)\n              : next ? range.moveEndTo(next.key, 0) : range.deselect()\n          }\n\n          // If the range wasn't deselected, normalize it.\n          if (range.isSet) return range.normalize(document)\n          return range\n        }\n      )\n    }\n\n    // Remove the node from the document.\n    let parent = document.getParent(node.key)\n    const index = parent.nodes.indexOf(node)\n    parent = parent.removeNode(index)\n    document = document.updateNode(parent)\n\n    // Update the document and range.\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Remove `text` at `offset` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  remove_text(value, operation) {\n    const { path, offset, text } = operation\n    const { length } = text\n    const rangeOffset = offset + length\n    let { document } = value\n\n    let node = document.assertPath(path)\n\n    // if insert happens within atomic ranges, clear\n    value = clearAtomicRangesIfContains(\n      value,\n      node.key,\n      offset,\n      offset + length\n    )\n\n    value = applyRangeAdjustments(\n      value,\n      // if anchor of range is here\n      ({ anchorKey }) => anchorKey == node.key,\n      // adjust if it is in or past the removal range\n      range =>\n        range.anchorOffset >= rangeOffset\n          ? range.moveAnchor(-length)\n          : range.anchorOffset > offset\n            ? range.moveAnchorTo(range.anchorKey, offset)\n            : range\n    )\n\n    value = applyRangeAdjustments(\n      value,\n      // if focus of range is here\n      ({ focusKey }) => focusKey == node.key,\n      // adjust if it is in or past the removal range\n      range =>\n        range.focusOffset >= rangeOffset\n          ? range.moveFocus(-length)\n          : range.focusOffset > offset\n            ? range.moveFocusTo(range.focusKey, offset)\n            : range\n    )\n\n    node = node.removeText(offset, length)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Set `properties` on mark on text at `offset` and `length` in node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_mark(value, operation) {\n    const { path, offset, length, mark, properties } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.updateMark(offset, length, mark, properties)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Set `properties` on a node by `path`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_node(value, operation) {\n    const { path, properties } = operation\n    let { document } = value\n    let node = document.assertPath(path)\n    node = node.merge(properties)\n    document = document.updateNode(node)\n    value = value.set('document', document)\n    return value\n  },\n\n  /**\n   * Set `properties` on the selection.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_selection(value, operation) {\n    const { properties } = operation\n    const { anchorPath, focusPath, ...props } = properties\n    let { document, selection } = value\n\n    if (anchorPath !== undefined) {\n      props.anchorKey =\n        anchorPath === null ? null : document.assertPath(anchorPath).key\n    }\n\n    if (focusPath !== undefined) {\n      props.focusKey =\n        focusPath === null ? null : document.assertPath(focusPath).key\n    }\n\n    selection = selection.merge(props)\n    selection = selection.normalize(document)\n    value = value.set('selection', selection)\n    return value\n  },\n\n  /**\n   * Set `properties` on `value`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  set_value(value, operation) {\n    const { properties } = operation\n    value = value.merge(properties)\n    return value\n  },\n\n  /**\n   * Split a node by `path` at `offset`.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  split_node(value, operation) {\n    const { path, position, properties } = operation\n    let { document } = value\n\n    // Calculate a few things...\n    const node = document.assertPath(path)\n    let parent = document.getParent(node.key)\n    const index = parent.nodes.indexOf(node)\n\n    // Split the node by its parent.\n    parent = parent.splitNode(index, position)\n\n    if (properties) {\n      const splitNode = parent.nodes.get(index + 1)\n\n      if (splitNode.object !== 'text') {\n        parent = parent.updateNode(splitNode.merge(properties))\n      }\n    }\n\n    document = document.updateNode(parent)\n    const next = document.getNextText(node.key)\n\n    value = applyRangeAdjustments(\n      value,\n      // check if range is affected\n      ({ startKey, startOffset, endKey, endOffset }) =>\n        (node.key == startKey && position <= startOffset) ||\n        (node.key == endKey && position <= endOffset),\n      // update its start / end as needed\n      range => {\n        const { startKey, startOffset, endKey, endOffset } = range\n        let normalize = false\n\n        if (node.key == startKey && position <= startOffset) {\n          range = range.moveStartTo(next.key, startOffset - position)\n          normalize = true\n        }\n\n        if (node.key == endKey && position <= endOffset) {\n          range = range.moveEndTo(next.key, endOffset - position)\n          normalize = true\n        }\n\n        // Normalize the selection if we changed it\n        if (normalize) return range.normalize(document)\n        return range\n      }\n    )\n\n    // Return the updated value.\n    value = value.set('document', document)\n    return value\n  },\n}\n\n/**\n * Apply an `operation` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} operation\n * @return {Value} value\n */\n\nfunction applyOperation(value, operation) {\n  operation = Operation.create(operation)\n  const { type } = operation\n  const apply = APPLIERS[type]\n\n  if (!apply) {\n    throw new Error(`Unknown operation type: \"${type}\".`)\n  }\n\n  debug(type, operation)\n  value = apply(value, operation)\n  return value\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default applyOperation\n","import Debug from 'debug'\nimport isPlainObject from 'is-plain-object'\nimport logger from '@gitbook/slate-dev-logger'\nimport pick from 'lodash/pick'\nimport { List } from 'immutable'\n\nimport MODEL_TYPES, { isType } from '../constants/model-types'\nimport Changes from '../changes'\nimport Operation from './operation'\nimport apply from '../operations/apply'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:change')\n\n/**\n * Change.\n *\n * @type {Change}\n */\n\nclass Change {\n  /**\n   * Check if `any` is a `Change`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isChange = isType.bind(null, 'CHANGE')\n\n  /**\n   * Create a new `Change` with `attrs`.\n   *\n   * @param {Object} attrs\n   *   @property {Value} value\n   */\n\n  constructor(attrs) {\n    const { value } = attrs\n    this.value = value\n    this.operations = new List()\n\n    this.flags = {\n      normalize: true,\n      ...pick(attrs, ['merge', 'save', 'normalize']),\n    }\n  }\n\n  /**\n   * Object.\n   *\n   * @return {String}\n   */\n\n  get object() {\n    return 'change'\n  }\n\n  get kind() {\n    logger.deprecate(\n      'slate@0.32.0',\n      'The `kind` property of Slate objects has been renamed to `object`.'\n    )\n    return this.object\n  }\n\n  /**\n   * Apply an `operation` to the current value, saving the operation to the\n   * history if needed.\n   *\n   * @param {Operation|Object} operation\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  applyOperation(operation, options = {}) {\n    const { operations, flags } = this\n    let { value } = this\n    let { history } = value\n\n    // Add in the current `value` in case the operation was serialized.\n    if (isPlainObject(operation)) {\n      operation = { ...operation, value }\n    }\n\n    operation = Operation.create(operation)\n\n    // Default options to the change-level flags, this allows for setting\n    // specific options for all of the operations of a given change.\n    options = { ...flags, ...options }\n\n    // Derive the default option values.\n    const {\n      merge = operations.size == 0 ? null : true,\n      save = true,\n      skip = null,\n    } = options\n\n    // Apply the operation to the value.\n    debug('apply', { operation, save, merge })\n    value = apply(value, operation)\n\n    // If needed, save the operation to the history.\n    if (history && save) {\n      history = history.save(operation, { merge, skip })\n      value = value.set('history', history)\n    }\n\n    // Update the mutable change object.\n    this.value = value\n    this.operations = operations.push(operation)\n    return this\n  }\n\n  /**\n   * Apply a series of `operations` to the current value.\n   *\n   * @param {Array|List} operations\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  applyOperations(operations, options) {\n    operations.forEach(op => this.applyOperation(op, options))\n    return this\n  }\n\n  /**\n   * Call a change `fn` with arguments.\n   *\n   * @param {Function} fn\n   * @param {Mixed} ...args\n   * @return {Change}\n   */\n\n  call(fn, ...args) {\n    fn(this, ...args)\n    return this\n  }\n\n  /**\n   * Applies a series of change mutations and defers normalization until the end.\n   *\n   * @param {Function} customChange - function that accepts a change object and executes change operations\n   * @return {Change}\n   */\n\n  withoutNormalization(customChange) {\n    const original = this.flags.normalize\n    this.setOperationFlag('normalize', false)\n\n    try {\n      customChange(this)\n      // if the change function worked then run normalization\n      this.normalizeDocument()\n    } finally {\n      // restore the flag to whatever it was\n      this.setOperationFlag('normalize', original)\n    }\n    return this\n  }\n\n  /**\n   * Set an operation flag by `key` to `value`.\n   *\n   * @param {String} key\n   * @param {Any} value\n   * @return {Change}\n   */\n\n  setOperationFlag(key, value) {\n    this.flags[key] = value\n    return this\n  }\n\n  /**\n   * Get the `value` of the specified flag by its `key`. Optionally accepts an `options`\n   * object with override flags.\n   *\n   * @param {String} key\n   * @param {Object} options\n   * @return {Change}\n   */\n\n  getFlag(key, options = {}) {\n    return options[key] !== undefined ? options[key] : this.flags[key]\n  }\n\n  /**\n   * Unset an operation flag by `key`.\n   *\n   * @param {String} key\n   * @return {Change}\n   */\n\n  unsetOperationFlag(key) {\n    delete this.flags[key]\n    return this\n  }\n}\n\n/**\n * Attach a pseudo-symbol for type checking.\n */\n\nChange.prototype[MODEL_TYPES.CHANGE] = true\n\n/**\n * Add a change method for each of the changes.\n */\n\nObject.keys(Changes).forEach(type => {\n  Change.prototype[type] = function(...args) {\n    debug(type, { args })\n    this.call(Changes[type], ...args)\n    return this\n  }\n})\n\n/**\n * Export.\n *\n * @type {Change}\n */\n\nexport default Change\n","import apply from './apply'\nimport invert from './invert'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  apply,\n  invert,\n}\n","import { resetMemoization, useMemoization } from 'immutablejs-record-memoize'\n\nimport Block from './models/block'\nimport Change from './models/change'\nimport Changes from './changes'\nimport Character from './models/character'\nimport Data from './models/data'\nimport Document from './models/document'\nimport History from './models/history'\nimport Inline from './models/inline'\nimport Leaf from './models/leaf'\nimport Mark from './models/mark'\nimport Node from './models/node'\nimport Operation from './models/operation'\nimport Operations from './operations'\nimport Range from './models/range'\nimport Schema from './models/schema'\nimport Stack from './models/stack'\nimport Text from './models/text'\nimport Value from './models/value'\nimport { resetKeyGenerator, setKeyGenerator } from './utils/generate-key'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Block,\n  Change,\n  Changes,\n  Character,\n  Data,\n  Document,\n  History,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Operations,\n  Range,\n  Schema,\n  Stack,\n  Text,\n  Value,\n  resetKeyGenerator,\n  setKeyGenerator,\n  resetMemoization,\n  useMemoization,\n}\n\nexport default {\n  Block,\n  Changes,\n  Character,\n  Data,\n  Document,\n  History,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Operations,\n  Range,\n  Schema,\n  Stack,\n  Text,\n  Value,\n  resetKeyGenerator,\n  setKeyGenerator,\n  resetMemoization,\n  useMemoization,\n}\n"],"names":["MODEL_TYPES","isType","type","any","n","generate","generateKey","setKeyGenerator","func","resetKeyGenerator","DEFAULTS","Map","undefined","List","Block","options","object","isVoid","data","toJS","nodes","toArray","map","preserveKeys","key","deprecate","some","child","isEmpty","getText","attrs","isBlock","isPlainObject","fromJS","Error","isList","Array","isArray","list","create","block","createChildren","every","item","Record","bind","prototype","BLOCK","Inline","isInline","elements","inline","INLINE","Data","isMap","Mark","schema","__getComponent","isMark","Set","isSet","marks","props","mark","MARK","memoize","Changes","PROXY_TRANSFORMS","forEach","method","change","args","value","selection","methodAtRange","match","collapseToStart","collapseToEnd","setBlock","setBlocks","setInline","setInlines","addMark","document","isExpanded","addMarkAtRange","add","sel","set","select","getActiveMarksAtRange","addMarks","delete","deleteAtRange","insertBlock","insertBlockAtRange","node","getNode","collapseToEndOf","insertFragment","fragment","size","startText","endText","startInline","lastText","getLastText","lastInline","getClosestInline","firstChild","first","lastChild","last","keys","getTexts","text","isAppending","hasEdgeAtStartOf","hasEdgeAtEndOf","isInserting","hasBlocks","insertFragmentAtRange","newTexts","filter","includes","newText","takeLast","collapseToStartOf","move","length","insertInline","insertInlineAtRange","insertText","getInsertMarksAtRange","insertTextAtRange","splitBlock","depth","splitBlockAtRange","removeMark","removeMarkAtRange","remove","replaceMark","oldMark","newMark","toggleMark","exists","activeMarks","has","wrapText","prefix","suffix","wrapTextAtRange","isCollapsed","moveStart","moveEnd","isForward","flip","Document","isDocument","DOCUMENT","Range","anchorOffset","getFirst","anchorKey","getLast","start","end","hasAnchorIn","hasDescendant","focusKey","focusOffset","hasFocusIn","hasAnchorAtStartOf","hasAnchorAtEndOf","merge","isBackward","offset","moveAnchorOffsetTo","moveFocusOffsetTo","moveFocusTo","moveAnchorTo","range","moveAnchorToStartOf","moveFocusToEndOf","anchorOffsetType","focusOffsetType","warn","anchorNode","getDescendant","focusNode","getFirstText","anchorText","getTextAtOffset","getOffset","focusText","areDescendantsSorted","isFocused","m","isAtomic","isRange","anchorPath","focusPath","createSet","obj","RANGE","MOVE_METHODS","p","s","EDGE_METHODS","hasEdge","anchor","focus","ALIAS_METHODS","alias","Character","isCharacter","split","character","CHARACTER","Leaf","characters","createList","char","equals","newMarks","withMutations","union","isLeaf","leaves","invalid","result","findLast","leaf","index","firstLeaf","cache","unshift","endOffset","left","right","find","startOffset","slice","of","take","skip","push","LEAF","Text","reduce","string","l","newFirst","splitLeaves","before","bundle","middle","after","concat","x","setLeaves","__getDecorations","decorations","startKey","endKey","hasStart","hasEnd","createLeaves","getActiveMarks","leafEnd","leafStart","intersect","c","getMarks","array","getMarksAsArray","OrderedSet","apply","searchLeafAtOffset","delta","beforeText","afterText","nextLeaves","splice","getLeaves","r","properties","updateMark","splitted","one","two","regenerateKey","validateNode","validate","getString","flatMap","getCharacters","isText","TEXT","Node","second","assertKey","getKeysAsArray","firstIndex","indexOf","secondIndex","getChild","descendant","path","getDescendantAtPath","iterator","matches","forEachDescendant","i","found","ret","hasChild","ancestors","getAncestors","getBlocksAsArray","isLeafBlock","getBlocksAtRangeAsArray","normalize","isUnset","startBlock","getClosestBlock","endBlock","blocks","getBlocksByTypeAsArray","t","getTextsAtRange","rest","getClosest","parent","assertDescendant","oneParent","getParent","twoParent","stack","startAt","getFurthestAncestor","getDepth","descendantFound","get","previous","position","splitNode","updateNode","getNextText","startNode","getNextSibling","endNode","startIndex","endIndex","getFurthest","shift","reverse","takeUntil","getInlinesAsArray","isLeafInline","getInlinesAtRangeAsArray","getTextsAtRangeAsArray","getInlinesByTypeAsArray","inlines","desc","getOrderedMarksAtRange","getMarksAtPosition","getMarksAtIndex","getOrderedMarksBetweenPositions","getMarksBetweenOffsets","texts","getTextsBetweenPositionsAsArray","toSet","getPreviousText","getActiveMarksBetweenOffsets","startMarks","endMarks","currentMarks","closestBlock","getMarksByTypeAsArray","next","skipUntil","memo","assertNode","ancestor","getPath","__getPlaceholder","isSelected","dir","direction","getTextsAsArray","getClosestVoid","mapDescendants","insert","withIndex","mergeText","removeNode","insertNode","findIndex","splitText","befores","afters","getFirstInvalidDescendant","isNode","kind","fromJSON","arg","Object","getOwnPropertyNames","SURROGATE_START","SURROGATE_END","SPACE","CHAMELEON","PUNCTUATION","isSurrogate","code","isWord","remaining","test","charAt","getCharLength","charCodeAt","getCharOffset","getCharOffsetBackward","getCharOffsetForward","getWordOffset","started","getWordOffsetBackward","o","getWordOffsetForward","getFlag","addMarkByKey","addMarksAtRange","snapshotSelection","isStartVoid","hasVoidParent","isEndVoid","isHanging","prevText","startVoid","nextText","removeNodeByKey","endVoid","removeTextByKey","startLength","endLength","getCommonAncestor","startChild","endChild","startParent","startParentIndex","endParentIndex","startChildIndex","endChildIndex","middles","lonely","getFurthestOnlyChildAncestor","moveNodeByKey","mergeNodeByKey","normalizeNodeByKey","deleteCharBackwardAtRange","String","deleteBackwardAtRange","deleteLineBackwardAtRange","deleteWordBackwardAtRange","voidParent","isAtStartOf","prev","prevBlock","prevVoid","traversed","deleteCharForwardAtRange","deleteForwardAtRange","deleteLineForwardAtRange","deleteWordForwardAtRange","nextBlock","getNextBlock","moveToStartOf","isAtEndOf","nextVoid","extra","insertNodeByKey","atEnd","siblingText","splitRange","moveToEndOf","splitDescendantsByKey","collapseTo","isAtStart","getBlocks","firstBlock","lastBlock","lonelyParent","lonelyChild","removeDescendant","newIndex","nextChild","nextNodes","lastIndex","inlineChild","inlineIndex","splitNodeByKey","insertTextByKey","commonAncestor","normalizeAncestor","normalizeKey","removeMarkByKey","setBlocksAtRange","getBlocksAtRange","sets","setNodeByKey","setBlockAtRange","setInlinesAtRange","getInlinesAtRange","setInlineAtRange","height","h","splitInlineAtRange","Infinity","toggleMarkAtRange","unwrapBlockAtRange","createProperties","wrappers","isSuperset","toOrderedSet","toList","children","b","firstMatch","lastMatch","firstText","normalizeDocument","unwrapInlineAtRange","wrapBlockAtRange","clear","firstblock","lastblock","siblings","p1","p2","indexes","ind","wrapInlineAtRange","inlineParent","wrapInlineByKey","endInline","inlinekey","rng","startInner","startInnerIndex","endInner","startInlines","endInlines","operations","bx","by","ax","ay","Math","max","min","applyOperations","insertFragmentByKey","applyOperation","original","getPreviousSibling","newKey","newPath","removeAllMarksByKey","state","setTextByKey","textNode","replaceTextByKey","activeMark","removals","replaceNodeByKey","newNode","setMarkByKey","target","textKey","textOffset","a","prevIndex","unwrapInlineByKey","moveToRangeOf","unwrapBlockByKey","unwrapNodeByKey","isFirst","isLast","parentParent","parentIndex","wrapBlockByKey","wrapNodeByKey","OPERATION_ATTRIBUTES","debug","Debug","Stack","History","operation","history","undos","redos","prevBatch","peek","prevOperation","shouldSkip","shouldMerge","batch","pop","isHistory","createOperationsList","HISTORY","isEqual","CORE_SCHEMA_RULES","invalids","objects","insertBefore","insertAfter","Boolean","property","plugins","plugin","getPluginsWith","reduceRight","STACK","Schema","parents","rule","violation","context","CHILD_OBJECT_INVALID","CHILD_TYPE_INVALID","CHILD_UNKNOWN","FIRST_CHILD_OBJECT_INVALID","FIRST_CHILD_TYPE_INVALID","LAST_CHILD_OBJECT_INVALID","LAST_CHILD_TYPE_INVALID","CHILD_REQUIRED","NODE_TEXT_INVALID","PARENT_OBJECT_INVALID","PARENT_TYPE_INVALID","NODE_DATA_INVALID","NODE_IS_VOID_INVALID","NODE_MARK_INVALID","getRule","getParentRules","ctx","fail","fn","def","types","nextDef","defs","rewind","isSchema","rules","resolveSchema","SCHEMA","d","resolveDocumentRule","bs","is","resolveNodeRule","customizer","source","Value","Change","preserveData","preserveDecorations","preserveHistory","preserveSelection","preserveSchema","withPath","decoration","isBlurred","getPreviousBlock","getNextInline","getPreviousInline","getCharactersAtRange","getMarksAtRange","getFragmentAtRange","isValue","assertPath","save","VALUE","Operation","json","ATTRIBUTES","v","isOperation","OPERATION","invertOperation","op","inverse","inversePath","inverseNewPath","pathLast","newPathLast","e","inverseNode","inverseProperties","pick","inverseMark","inverseSelection","inverseProps","inverseValue","redo","omit","undo","invert","snapshot","k","moved","hasOwnProperty","selectAll","moveAnchorCharBackward","anchorBlock","previousText","isInVoid","isPreviousInVoid","moveAnchor","moveAnchorToEndOf","hasNode","moveAnchorCharForward","isNextInVoid","moveFocusCharBackward","focusBlock","moveFocus","moveFocusCharForward","moveFocusToStartOf","MOVE_DIRECTIONS","collapse","PREFIXES","DIRECTIONS","OBJECTS","edges","edge","getDirectionNode","directionKey","setValue","normalizeNodeAndChildren","refindNode","refindPath","normalizeNode","iterations","iterate","AtCurrentRange","AtRange","ByKey","OnHistory","OnSelection","OnValue","WithSchema","applyRangeAdjustments","checkAffected","adjustRange","clearAtomicRangesIfContains","offsetEnd","deselect","APPLIERS","oneIndex","twoIndex","mergeNode","newParentPath","oldParentPath","oldIndex","moveStartTo","moveEndTo","rangeOffset","removeText","flags","customChange","setOperationFlag","isChange","CHANGE","call"],"mappings":"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"}