'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*
 * GLOBAL: True if memoization should is enabled.	 * GLOBAL: True if memoization should is enabled.
 */
var ENABLED = true;

/*
 * The node of a cache tree for a WeakMap to store cache visited by objects
 */
var STORE_KEY = Symbol('STORE_KEY');

/*
 * The leaf node of a cache tree. Used to support variable argument length. A
 * unique object, so that native Maps will key it by reference.
 */
var LEAF = Symbol('LEAF');

/*
 * A value to represent a memoized undefined value. Allows efficient value
 * retrieval using Map.get only.
 */
var UNDEFINED = Symbol('undefined');
var NULL = Symbol('null');

/*
 * Default value for unset keys in native Maps
 */
var UNSET = undefined;

/*
 * Global Store for all cached values
 */
var memoizeStore = new WeakMap();

/*
 * Memoize all of the `properties` on an `object`.
 */
function memoize(
// The object prototype that should have its properties memoized.
object,
// The list of properties names that should be memoized
properties) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        var _loop = function _loop() {
            var property = _step.value;

            var original = object[property];

            if (!original) {
                throw new Error('Object does not have a property named "' + property + '".');
            }

            object[property] = function () {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                // If memoization is disabled, call into the original method.
                if (!ENABLED) {
                    return original.apply(this, args);
                }

                if (!memoizeStore.has(this)) {
                    memoizeStore.set(this, {
                        noArgs: {},
                        hasArgs: {}
                    });
                }

                // $FlowFixMe `this` was just set

                var _memoizeStore$get = memoizeStore.get(this),
                    noArgs = _memoizeStore$get.noArgs,
                    hasArgs = _memoizeStore$get.hasArgs;

                var takesArguments = args.length !== 0;

                var cachedValue = void 0;
                var keys = [];

                if (takesArguments) {
                    keys = [property].concat(args);
                    cachedValue = getIn(hasArgs, keys);
                } else {
                    cachedValue = noArgs[property];
                }

                // If we've got a result already, return it.
                if (cachedValue !== UNSET) {
                    return cachedValue === UNDEFINED ? undefined : cachedValue;
                }

                // Otherwise calculate what it should be once and cache it.
                var value = original.apply(this, args);
                var v = value === undefined ? UNDEFINED : value;

                if (takesArguments) {
                    setIn(hasArgs, keys, v);
                } else {
                    noArgs[property] = v;
                }

                return value;
            };
        };

        for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            _loop();
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
}

/*
 * Get a value at a key path in a tree of Map.
 *
 * If not set, returns UNSET.
 * If the set value is undefined, returns UNDEFINED.
 */
function getIn(map, keys) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var key = _step2.value;

            if (key === undefined) {
                key = UNDEFINED;
            } else if (key === null) {
                key = NULL;
            }

            if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
                map = map[STORE_KEY] && map[STORE_KEY].get(key);
            } else {
                map = map[key];
            }

            if (map === UNSET) return UNSET;
        }
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    return map[LEAF];
}

/*
 * Set a value at a key path in a tree of Map, creating Maps on the go.
 */
function setIn(map, keys, value) {
    var child = map;

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
        for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var key = _step3.value;

            if (key === undefined) {
                key = UNDEFINED;
            } else if (key === null) {
                key = NULL;
            }

            if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) !== 'object') {
                if (!child[key]) {
                    child[key] = {};
                }

                child = child[key];
                continue;
            }

            if (!child[STORE_KEY]) {
                child[STORE_KEY] = new WeakMap();
            }

            if (!child[STORE_KEY].has(key)) {
                var newChild = {};
                child[STORE_KEY].set(key, newChild);
                child = newChild;
                continue;
            }

            child = child[STORE_KEY].get(key);
        }

        // The whole path has been created, so set the value to the bottom most map.
    } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
            }
        } finally {
            if (_didIteratorError3) {
                throw _iteratorError3;
            }
        }
    }

    child[LEAF] = value;
    return map;
}

/*
 * Clears the previously memoized values, globally.
 */

function resetMemoization() {
    memoizeStore = new WeakMap();
}

/*
 * In DEV mode, enable or disable the use of memoize values, globally.
 */

function useMemoization(enabled) {
    ENABLED = enabled;
}

exports.default = memoize;
exports.resetMemoization = resetMemoization;
exports.useMemoization = useMemoization;